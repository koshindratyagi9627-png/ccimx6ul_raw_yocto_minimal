From 8eb371e7afe04e86469ac605afbc5b8069bd8811 Mon Sep 17 00:00:00 2001
From: Hou Qi <qi.hou@nxp.com>
Date: Fri, 13 Sep 2024 22:57:00 +0900
Subject: [PATCH 10/19] V4L2VideoDecoder: Comment some unused ioctl

Upstream-Status: Inappropriate [NXP specific]
---
 media/gpu/v4l2/v4l2_queue.cc | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/media/gpu/v4l2/v4l2_queue.cc b/media/gpu/v4l2/v4l2_queue.cc
index afa5d91ddb4b4..de74d0da308c3 100644
--- a/media/gpu/v4l2/v4l2_queue.cc
+++ b/media/gpu/v4l2/v4l2_queue.cc
@@ -1101,10 +1101,12 @@ V4L2Queue::V4L2Queue(const IoctlAsCallback& ioctl_cb,
       weak_this_factory_(this) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
   struct v4l2_requestbuffers reqbufs = {
       .count = 0, .type = type_, .memory = V4L2_MEMORY_MMAP};
   supports_requests_ = (ioctl_cb_.Run(VIDIOC_REQBUFS, &reqbufs) == kIoctlOk) &&
                        (reqbufs.capabilities & V4L2_BUF_CAP_SUPPORTS_REQUESTS);
+#endif
 
   // Stateful backends for example do not support requests.
   VPLOG_IF(4, supports_requests_)
@@ -1754,10 +1756,14 @@ bool V4L2Request::ApplyCtrls(struct v4l2_ext_controls* ctrls) {
     return false;
   }
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
   ctrls->which = V4L2_CTRL_WHICH_REQUEST_VAL;
   ctrls->request_fd = request_fd_.get();
 
   return true;
+#else
+  return false;
+#endif
 }
 
 bool V4L2Request::ApplyQueueBuffer(struct v4l2_buffer* buffer) {
@@ -1769,10 +1775,14 @@ bool V4L2Request::ApplyQueueBuffer(struct v4l2_buffer* buffer) {
     return false;
   }
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
   buffer->flags |= V4L2_BUF_FLAG_REQUEST_FD;
   buffer->request_fd = request_fd_.get();
 
   return true;
+#else
+  return false;
+#endif
 }
 
 bool V4L2Request::Submit() {
@@ -1783,12 +1793,16 @@ bool V4L2Request::Submit() {
     return false;
   }
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
   if (HANDLE_EINTR(ioctl(request_fd_.get(), MEDIA_REQUEST_IOC_QUEUE)) != 0) {
     RecordMediaIoctlUMA(MediaIoctlRequests::kMediaRequestIocQueue);
     return false;
   }
 
   return true;
+#else
+  return false;
+#endif
 }
 
 bool V4L2Request::IsCompleted() {
@@ -1830,6 +1844,7 @@ bool V4L2Request::Reset() {
     return false;
   }
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
   // Reinit the request to make sure we can use it for a new submission.
   if (HANDLE_EINTR(ioctl(request_fd_.get(), MEDIA_REQUEST_IOC_REINIT)) < 0) {
     RecordMediaIoctlUMA(MediaIoctlRequests::kMediaRequestIocReinit);
@@ -1838,6 +1853,9 @@ bool V4L2Request::Reset() {
   }
 
   return true;
+#else
+  return false;
+#endif
 }
 
 V4L2RequestRefBase::V4L2RequestRefBase(V4L2RequestRefBase&& req_base) {
@@ -1914,6 +1932,7 @@ V4L2RequestsQueue::~V4L2RequestsQueue() {
 std::optional<base::ScopedFD> V4L2RequestsQueue::CreateRequestFD() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
   int request_fd;
   int ret = HANDLE_EINTR(
       ioctl(media_fd_.get(), MEDIA_IOC_REQUEST_ALLOC, &request_fd));
@@ -1924,6 +1943,9 @@ std::optional<base::ScopedFD> V4L2RequestsQueue::CreateRequestFD() {
   }
 
   return base::ScopedFD(request_fd);
+#else
+  return std::nullopt;
+#endif
 }
 
 std::optional<V4L2RequestRef> V4L2RequestsQueue::GetFreeRequest() {
-- 
2.34.1

