From: Javier Viguera <javier.viguera@digi.com>
Date: Mon, 15 Sep 2025 11:54:08 +0200
Subject: [PATCH] ccimx95dvk: add new platform (config and board)

Verbatim copy of the mx95evk

Upstream-Status: Inappropriate [DEY specific]

Signed-off-by: Javier Viguera <javier.viguera@digi.com>
---
 boards/ccimx95dvk/board.c              | 579 ++++++++++++++
 boards/ccimx95dvk/board.h              | 164 ++++
 boards/ccimx95dvk/pin_mux.c            |  58 ++
 boards/ccimx95dvk/pin_mux.h            |  44 ++
 boards/ccimx95dvk/sm/Makefile          |  70 ++
 boards/ccimx95dvk/sm/brd_sm.c          | 665 +++++++++++++++++
 boards/ccimx95dvk/sm/brd_sm.dox        |  55 ++
 boards/ccimx95dvk/sm/brd_sm.h          | 100 +++
 boards/ccimx95dvk/sm/brd_sm_bbm.c      | 674 +++++++++++++++++
 boards/ccimx95dvk/sm/brd_sm_bbm.h      | 242 ++++++
 boards/ccimx95dvk/sm/brd_sm_control.c  | 317 ++++++++
 boards/ccimx95dvk/sm/brd_sm_control.h  | 202 +++++
 boards/ccimx95dvk/sm/brd_sm_handlers.c | 372 +++++++++
 boards/ccimx95dvk/sm/brd_sm_handlers.h | 129 ++++
 boards/ccimx95dvk/sm/brd_sm_sensor.c   | 375 ++++++++++
 boards/ccimx95dvk/sm/brd_sm_sensor.h   | 210 ++++++
 boards/ccimx95dvk/sm/brd_sm_voltage.c  | 565 ++++++++++++++
 boards/ccimx95dvk/sm/brd_sm_voltage.h  | 213 ++++++
 configs/ccimx95dvk.cfg                 | 997 +++++++++++++++++++++++++
 19 files changed, 6031 insertions(+)
 create mode 100755 boards/ccimx95dvk/board.c
 create mode 100755 boards/ccimx95dvk/board.h
 create mode 100755 boards/ccimx95dvk/pin_mux.c
 create mode 100755 boards/ccimx95dvk/pin_mux.h
 create mode 100755 boards/ccimx95dvk/sm/Makefile
 create mode 100755 boards/ccimx95dvk/sm/brd_sm.c
 create mode 100755 boards/ccimx95dvk/sm/brd_sm.dox
 create mode 100755 boards/ccimx95dvk/sm/brd_sm.h
 create mode 100755 boards/ccimx95dvk/sm/brd_sm_bbm.c
 create mode 100755 boards/ccimx95dvk/sm/brd_sm_bbm.h
 create mode 100755 boards/ccimx95dvk/sm/brd_sm_control.c
 create mode 100755 boards/ccimx95dvk/sm/brd_sm_control.h
 create mode 100755 boards/ccimx95dvk/sm/brd_sm_handlers.c
 create mode 100755 boards/ccimx95dvk/sm/brd_sm_handlers.h
 create mode 100755 boards/ccimx95dvk/sm/brd_sm_sensor.c
 create mode 100755 boards/ccimx95dvk/sm/brd_sm_sensor.h
 create mode 100755 boards/ccimx95dvk/sm/brd_sm_voltage.c
 create mode 100755 boards/ccimx95dvk/sm/brd_sm_voltage.h
 create mode 100755 configs/ccimx95dvk.cfg

diff --git a/boards/ccimx95dvk/board.c b/boards/ccimx95dvk/board.c
new file mode 100755
index 000000000000..d4a671f6d7f8
--- /dev/null
+++ b/boards/ccimx95dvk/board.c
@@ -0,0 +1,579 @@
+/*
+ * Copyright 2023-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include "sm.h"
+#include "board.h"
+#include "brd_sm_voltage.h"
+#include "fsl_lpuart.h"
+#include "fsl_lpi2c.h"
+#include "fsl_ccm.h"
+#include "fsl_clock.h"
+#include "fsl_bbnsm.h"
+#include "fsl_reset.h"
+#include "fsl_sysctr.h"
+#include "fsl_systick.h"
+#include "fsl_wdog32.h"
+#include "fsl_cache.h"
+#include "fsl_iomuxc.h"
+#include "fsl_fro.h"
+
+/*******************************************************************************
+ * Definitions
+ ******************************************************************************/
+
+/* External board-level clock rates */
+#define BOARD_EXT_CLK_RATE          25000000UL  /* 25MHz */
+
+/* ADC clck rate */
+#define BOARD_ADC_CLK_RATE          80000000UL  /* 80MHz */
+
+/* SM SysTick parameters */
+#define BOARD_SYSTICK_CLKSRC    0U                      /* 0 = external ref  */
+#define BOARD_SYSTICK_CLK_ROOT  CLOCK_ROOT_M33SYSTICK   /* Dedicated CCM root */
+
+/* SM WDOG */
+#define BOARD_WDOG_BASE_PTR         WDOG2
+#define BOARD_WDOG_IRQn             WDOG2_IRQn
+#define BOARD_WDOG_CLK_SRC          kWDOG32_ClockSource1  /* lpo_clk @ 32K */
+#define BOARD_WDOG_TIMEOUT          0xFFFFU  /* 65535 ticks @ 32K = 2 sec */
+#define BOARD_WDOG_SRMASK           (1UL << RST_REASON_WDOG2)
+#define BOARD_WDOG_ANY_INIT         ~(BLK_CTRL_S_AONMIX_WDOG_ANY_MASK_WDOG2_MASK)
+#define BOARD_WDOG_ANY_MASK         BLK_CTRL_S_AONMIX_WDOG_ANY_MASK_WDOG2_MASK
+#define BOARD_WDOG_IPG_DEBUG        BLK_CTRL_NS_AONMIX_IPG_DEBUG_CM33_WDOG2_MASK
+
+/* Board UART */
+#ifdef INC_LIBC
+#define BOARD_UART                  BOARD_DEBUG_UART_INSTANCE
+#else
+#define BOARD_UART                  0U
+#endif
+
+/*******************************************************************************
+ * Variables
+ ******************************************************************************/
+static wdog32_config_t s_wdogConfig;
+
+/* Debug UART base pointer list */
+static LPUART_Type *const s_uartBases[] = LPUART_BASE_PTRS;
+
+/* Debug UART base pointer list */
+static IRQn_Type const s_uartIrqs[] = LPUART_RX_TX_IRQS;
+
+/* Debug UART clock list */
+static uint32_t const s_uartClks[] =
+{
+    0U,
+    CLOCK_ROOT_LPUART1,
+    CLOCK_ROOT_LPUART2,
+    CLOCK_ROOT_LPUART3,
+    CLOCK_ROOT_LPUART4,
+    CLOCK_ROOT_LPUART5,
+    CLOCK_ROOT_LPUART6,
+    CLOCK_ROOT_LPUART7,
+    CLOCK_ROOT_LPUART8
+};
+
+/* Debug UART peripheral LPI list */
+static uint32_t const s_uartPerLpi[] =
+{
+    0U,
+    CPU_PER_LPI_IDX_LPUART1,
+    CPU_PER_LPI_IDX_LPUART2,
+    CPU_PER_LPI_IDX_LPUART3,
+    CPU_PER_LPI_IDX_LPUART4,
+    CPU_PER_LPI_IDX_LPUART5,
+    CPU_PER_LPI_IDX_LPUART6,
+    CPU_PER_LPI_IDX_LPUART7,
+    CPU_PER_LPI_IDX_LPUART8
+};
+
+/* Debug UART configuration info */
+static board_uart_config_t const s_uartConfig =
+{
+    .base = s_uartBases[BOARD_UART],
+    .irq = s_uartIrqs[BOARD_UART],
+    .clockId = s_uartClks[BOARD_UART],
+    .perLpiId = s_uartPerLpi[BOARD_UART],
+    .baud = BOARD_DEBUG_UART_BAUDRATE,
+    .inst = BOARD_UART
+};
+
+/*******************************************************************************
+ * Code
+ ******************************************************************************/
+
+/*--------------------------------------------------------------------------*/
+/* Configure CM33 MPU and XCACHE controller                                 */
+/*--------------------------------------------------------------------------*/
+void BOARD_ConfigMPU(void)
+{
+    uint8_t attr;
+
+    /* Disable code cache(ICache) and system cache(DCache) */
+    XCACHE_DisableCache(LPCAC_PC);
+    XCACHE_DisableCache(LPCAC_PS);
+
+    /* NOTE: All TCRAM is non-cacheable regardless of MPU setting. */
+
+    /*
+     * default cache policy(default memory access behavior) after enable
+     * mpu on cortex-m33(according to RM of cortex-m33):
+     * 0x00000000-0x1FFFFFFF Normal memory, Non-shareable, Write-Through,
+     *                       not Write Allocate
+     * 0x20000000-0x3FFFFFFF Normal memory, Non-shareable, Write-Back,
+     *                       Write Allocate
+     * 0x40000000-0x5FFFFFFF Device, Shareable
+     * 0x60000000-0x7FFFFFFF Normal memory, Non-shareable, Write-Back,
+     *                       Write Allocate
+     * 0x80000000-0x9FFFFFFF Normal memory, Non-shareable, Write-Through,
+     *                       not Write Allocate
+     * 0xA0000000-0xDFFFFFFF Device, Shareable
+     * 0xE0000000-0xE003FFFF Device, Shareable
+     * 0xE0040000-0xE0043FFF Device, Shareable
+     * 0xE0044000-0xE00EFFFF Device, Shareable
+     * 0xF0000000-0xFFFFFFFF Device, Shareable
+     */
+    /* Disable MPU */
+    ARM_MPU_Disable();
+
+    /* Attr0: Device-nGnRnE */
+    // coverity[misra_c_2012_rule_14_3_violation:FALSE]
+    ARM_MPU_SetMemAttr(0U, ARM_MPU_ATTR(ARM_MPU_ATTR_DEVICE,
+        ARM_MPU_ATTR_DEVICE));
+
+    /* Attr1: Normal memory, Outer non-cacheable, Inner non-cacheable */
+    // coverity[misra_c_2012_rule_14_3_violation:FALSE]
+    ARM_MPU_SetMemAttr(1U, ARM_MPU_ATTR(ARM_MPU_ATTR_NON_CACHEABLE,
+        ARM_MPU_ATTR_NON_CACHEABLE));
+
+    /* Attr2: Normal memory, Inner write-through transient, read allocate.
+     * Inner write-through transient, read allocate
+     */
+    attr = ARM_MPU_ATTR_MEMORY_(0U, 0U, 1U, 0U);
+    ARM_MPU_SetMemAttr(2U, ARM_MPU_ATTR(attr, attr));
+
+    /* Attr3: Normal memory, Outer write-back transient, read/write allocate.
+     * Inner write-back transient, read/write
+     * allocate */
+    attr = ARM_MPU_ATTR_MEMORY_(0U, 1U, 1U, 1U);
+    ARM_MPU_SetMemAttr(3U, ARM_MPU_ATTR(attr, attr));
+
+    /*
+     * Change macro definitions as follows when choose cache policy
+     * as non-cacheable:
+     * #define DDR_NONCACHEABLE (1U)
+     * #define DDR_WRITE_THROUGH (0U)
+     * #define DDR_WRITE_BACK (0U)
+     *
+     *
+     * Change macro definitions as follows when choose cache policy
+     * as Write-Through:
+     * #define DDR_NONCACHEABLE (0U)
+     * #define DDR_WRITE_THROUGH (1U)
+     * #define DDR_WRITE_BACK (0U)
+     *
+     *
+     * Change macro definitions as follows when choose cache policy
+     * as Write-Back:
+     * #define DDR_NONCACHEABLE (0U)
+     * #define DDR_WRITE_THROUGH (0U)
+     * #define DDR_WRITE_BACK (1U)
+     */
+#define DDR_NONCACHEABLE  (1U)
+#define DDR_WRITE_THROUGH (0U)
+#define DDR_WRITE_BACK    (0U)
+#if DDR_NONCACHEABLE
+    /* NOTE: DDR is used as shared memory for A/M core communication,
+     * set it to non-cacheable. */
+    /* Region 0: [0x80000000, 0xDFFFFFFF](DRAM), outer shareable,
+     * read/write, any privileged, executable. Attr 1 (non-cacheable). */
+    ARM_MPU_SetRegion(0U, ARM_MPU_RBAR(0x80000000U, ARM_MPU_SH_OUTER, 0U,
+        1U, 0U), ARM_MPU_RLAR(0xDFFFFFFFU, 1U));
+#elif DDR_WRITE_THROUGH
+    /* Region 0: [0x80000000, 0xDFFFFFFF](DRAM), outer shareable, read/write,
+     * any privileged, executable. Attr 2
+     * (Normal memory, Inner write-through transient, read allocate. Inner
+     * write-through transient, read allocate). */
+    ARM_MPU_SetRegion(0U, ARM_MPU_RBAR(0x80000000U, ARM_MPU_SH_OUTER, 0U,
+        1U, 0U), ARM_MPU_RLAR(0xDFFFFFFFU, 2U));
+#elif DDR_WRITE_BACK
+    /* Region 0: [0x80000000, 0xDFFFFFFF](DRAM), outer shareable, read/write,
+     * any privileged, executable. Attr 3
+     * (Normal memory, Outer write-back transient, read/write allocate. Inner
+     * write-back transient, read/write allocate). */
+    ARM_MPU_SetRegion(0U, ARM_MPU_RBAR(0x80000000U, ARM_MPU_SH_OUTER, 0U,
+        1U, 0U), ARM_MPU_RLAR(0xDFFFFFFFU, 3U));
+#endif
+
+#define OCRAM_NONCACHEABLE  (1U)
+#define OCRAM_WRITE_THROUGH (0U)
+#define OCRAM_WRITE_BACK    (0U)
+#if OCRAM_NONCACHEABLE
+    /* Region 1: [0x20480000, 0x2051FFFF](OCRAM), outer shareable, read/write,
+     * any privileged, executable. Attr 1 (non-cacheable). */
+    ARM_MPU_SetRegion(1U, ARM_MPU_RBAR(0x20480000U, ARM_MPU_SH_OUTER, 0U,
+        1U, 0U), ARM_MPU_RLAR(0x2051FFFFU, 1U));
+#elif OCRAM_WRITE_THROUGH
+    /* Region 1: [0x20480000, 0x2051FFFF](OCRAM), outer shareable,
+     * read/write, any privileged, executable. Attr 2 (Normal memory, Inner
+     * write-through transient, read allocate. Inner write-through transient,
+     * read allocate). */
+    ARM_MPU_SetRegion(1U, ARM_MPU_RBAR(0x20480000U, ARM_MPU_SH_OUTER, 0U,
+        1U, 0U), ARM_MPU_RLAR(0x2051FFFFU, 2U));
+#elif OCRAM_WRITE_BACK
+    /* Region 1: [0x20480000, 0x2051FFFF](OCRAM), outer shareable,
+     * read/write, any privileged, executable. Attr 3 (Normal memory,
+     * Outer write-back transient, read/write allocate. Inner write-back
+     * transient, read/write allocate). */
+    ARM_MPU_SetRegion(1U, ARM_MPU_RBAR(0x20480000U, ARM_MPU_SH_OUTER, 0U,
+        1U, 0U), ARM_MPU_RLAR(0x2051FFFFU, 3U));
+#endif
+
+    /* Enable MPU(use default memory map when access the memory within
+     * region) */
+    ARM_MPU_Enable(MPU_CTRL_PRIVDEFENA_Msk);
+
+    /* Enable ICache and DCache */
+    XCACHE_EnableCache(LPCAC_PC);
+    XCACHE_EnableCache(LPCAC_PS);
+}
+
+/*--------------------------------------------------------------------------*/
+/* Initialize clocking                                                      */
+/*--------------------------------------------------------------------------*/
+void BOARD_InitClocks(void)
+{
+    uint32_t fuseTrim = DEV_SM_FuseGet(DEV_SM_FUSE_FRO_TRIM);
+
+    if (fuseTrim == 0U)
+    {
+        /* Enable the FRO clock with default value */
+        (void) FRO_SetEnable(true);
+    }
+    else
+    {
+        /* Set the Trim value read from the fuses */
+        bool status = FRO_SetTrim(fuseTrim);
+
+        if (status)
+        {
+            /* Enable the FRO clock with default value */
+            (void) FRO_SetEnable(true);
+        }
+    }
+
+    /* Configure default EXT_CLK1 rate tied to XTAL_OUT/EXT_CLK pin */
+    (void) CLOCK_SourceSetRate(CLOCK_SRC_EXT1, BOARD_EXT_CLK_RATE, 0U);
+
+    /* Configure ADC clock */
+    (void) CCM_RootSetParent(CLOCK_ROOT_ADC, CLOCK_SRC_SYSPLL1_PFD1_DIV2);
+    (void) CCM_RootSetRate(CLOCK_ROOT_ADC, BOARD_ADC_CLK_RATE,
+        CLOCK_ROUND_RULE_CEILING);
+}
+
+/*--------------------------------------------------------------------------*/
+/* Return the debug UART info                                               */
+/*--------------------------------------------------------------------------*/
+const board_uart_config_t *BOARD_GetDebugUart(void)
+{
+    return &s_uartConfig;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Initialize debug console                                                 */
+/*--------------------------------------------------------------------------*/
+void BOARD_InitDebugConsole(void)
+{
+    if (s_uartConfig.base != NULL)
+    {
+        uint64_t rate = CCM_RootGetRate(s_uartConfig.clockId);
+
+        /* Configure debug UART */
+        lpuart_config_t lpuart_config;
+        LPUART_GetDefaultConfig(&lpuart_config);
+        lpuart_config.baudRate_Bps = s_uartConfig.baud;
+        lpuart_config.rxFifoWatermark = ((uint8_t)
+            FSL_FEATURE_LPUART_FIFO_SIZEn(s_uartConfig.base)) - 1U;
+        lpuart_config.txFifoWatermark = ((uint8_t)
+            FSL_FEATURE_LPUART_FIFO_SIZEn(s_uartConfig.base)) - 1U;
+        lpuart_config.enableTx = true;
+        lpuart_config.enableRx = true;
+        (void) LPUART_Init(s_uartConfig.base, &lpuart_config,
+            U64_U32(rate));
+    }
+}
+
+/*--------------------------------------------------------------------------*/
+/* Initialize IRQ handlers                                                  */
+/*--------------------------------------------------------------------------*/
+void BOARD_InitHandlers(void)
+{
+    /* Configure default priority of exceptions and IRQs */
+    for (int32_t irq = ((int32_t) SVCall_IRQn); irq < ((int32_t)
+        NUMBER_OF_INT_VECTORS); irq++)
+    {
+        // coverity[misra_c_2012_rule_10_5_violation:FALSE]
+        NVIC_SetPriority((IRQn_Type) irq, IRQ_PRIO_NOPREEMPT_NORMAL);
+    }
+
+    /* Configure SWI handler */
+    NVIC_EnableIRQ(BOARD_SWI_IRQn);
+
+    /* Enable BBNSM handler */
+    NVIC_EnableIRQ(BBNSM_IRQn);
+
+    /* Enable GPC SM handler */
+    NVIC_SetPriority(GPC_SM_REQ_IRQn, IRQ_PRIO_NOPREEMPT_VERY_HIGH);
+    NVIC_EnableIRQ(GPC_SM_REQ_IRQn);
+
+    /* Enable ELE Group IRQ handlers */
+    NVIC_EnableIRQ(ELE_Group1_IRQn);
+    NVIC_EnableIRQ(ELE_Group2_IRQn);
+    NVIC_EnableIRQ(ELE_Group3_IRQn);
+
+    /* Enable FCCU handler */
+    NVIC_SetPriority(FCCU_INT0_IRQn, IRQ_PRIO_NOPREEMPT_CRITICAL);
+    NVIC_EnableIRQ(FCCU_INT0_IRQn);
+
+    /* Enable GPIO1 handler */
+    NVIC_EnableIRQ(GPIO1_0_IRQn);
+}
+
+/*--------------------------------------------------------------------------*/
+/* Initialize timers                                                        */
+/*--------------------------------------------------------------------------*/
+void BOARD_InitTimers(void)
+{
+    /* Configure and enable the BBNSM RTC */
+    bbnsm_rtc_config_t rtcConfig;
+    BBNSM_RTC_GetDefaultConfig(&rtcConfig);
+    BBNSM_RTC_Init(BBNSM, &rtcConfig);
+
+    /* Configure and enable system counter */
+    SYSCTR_Init();
+
+    /* Configure and enable M33 SysTick */
+    uint64_t rate = CCM_RootGetRate(BOARD_SYSTICK_CLK_ROOT);
+    uint32_t reloadVal = (uint32_t) (rate & 0xFFFFFFFFU);
+    reloadVal = ((reloadVal * BOARD_TICK_PERIOD_MSEC) + 999U) / 1000U;
+    SYSTICK_Init(1U, BOARD_SYSTICK_CLKSRC, (uint32_t) (rate & 0xFFFFFFFFU),
+        reloadVal);
+    NVIC_EnableIRQ(SysTick_IRQn);
+
+    /* Configure and enable the WDOG */
+    WDOG32_GetDefaultConfig(&s_wdogConfig);
+    s_wdogConfig.clockSource = BOARD_WDOG_CLK_SRC;
+    s_wdogConfig.timeoutValue = BOARD_WDOG_TIMEOUT;
+    s_wdogConfig.enableInterrupt = true;
+    WDOG32_Init(BOARD_WDOG_BASE_PTR, &s_wdogConfig);
+    NVIC_SetPriority(BOARD_WDOG_IRQn, IRQ_PRIO_PREEMPT_CRITICAL);
+
+    /* Configure to just non-FCCU SM watchdogs */
+    BLK_CTRL_S_AONMIX->WDOG_ANY_MASK = BOARD_WDOG_ANY_INIT;
+
+    /* Switch WDOG to COLD mode */
+    BOARD_WdogModeSet(BOARD_WDOG_MODE_COLD);
+
+    /* Halt SM WDOG on M33 debug entry */
+    BLK_CTRL_NS_AONMIX->IPG_DEBUG_CM33 = (BOARD_WDOG_IPG_DEBUG);
+
+    /* Halt CM7 WDOG on CM7 debug entry */
+    BLK_CTRL_WAKEUPMIX->IPG_DEBUG_CM7 =
+        BLK_CTRL_WAKEUPMIX_IPG_DEBUG_CM7_WDOG5_MASK;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Set watchdog mode                                                        */
+/*--------------------------------------------------------------------------*/
+void BOARD_WdogModeSet(uint32_t mode)
+{
+    switch (mode)
+    {
+        case BOARD_WDOG_MODE_WARM: /* warm */
+            /* Allow WDOG to generate internal warm reset */
+            SRC_GEN->SRMASK &= (~BOARD_WDOG_SRMASK);
+
+            /* Enable WDOG interrupt */
+            NVIC_EnableIRQ(BOARD_WDOG_IRQn);
+
+            /* Disable WDOG_ANY */
+            BLK_CTRL_S_AONMIX->WDOG_ANY_MASK |= BOARD_WDOG_ANY_MASK;
+
+            /* Drive WDOG_ANY from WDOG */
+            IOMUXC_SetPinMux(IOMUXC_PAD_WDOG_ANY__WDOG_ANY, 0U);
+            break;
+        case BOARD_WDOG_MODE_COLD: /* cold */
+            /* Allow WDOG to generate internal warm reset */
+            SRC_GEN->SRMASK &= (~BOARD_WDOG_SRMASK);
+
+            /* Enable WDOG interrupt */
+            NVIC_EnableIRQ(BOARD_WDOG_IRQn);
+
+            /* Enable WDOG_ANY */
+            BLK_CTRL_S_AONMIX->WDOG_ANY_MASK &= ~BOARD_WDOG_ANY_MASK;
+
+            /* Drive WDOG_ANY from WDOG */
+            IOMUXC_SetPinMux(IOMUXC_PAD_WDOG_ANY__WDOG_ANY, 0U);
+            break;
+        case BOARD_WDOG_MODE_IRQ: /* irq */
+            /* Enable WDOG interrupt */
+            NVIC_EnableIRQ(BOARD_WDOG_IRQn);
+
+            /* Disallow WDOG to generate internal warm reset */
+            SRC_GEN->SRMASK |= BOARD_WDOG_SRMASK;
+
+            /* Disable WDOG_ANY */
+            BLK_CTRL_S_AONMIX->WDOG_ANY_MASK |= BOARD_WDOG_ANY_MASK;
+
+            /* Drive WDOG_ANY from WDOG */
+            IOMUXC_SetPinMux(IOMUXC_PAD_WDOG_ANY__WDOG_ANY, 0U);
+            break;
+        case BOARD_WDOG_MODE_OFF:  /* off */
+            s_wdogConfig.enableWdog32 = false;
+            WDOG32_Deinit(BOARD_WDOG_BASE_PTR);
+            break;
+        case BOARD_WDOG_MODE_TRIGGER: /* trigger */
+            BOARD_WDOG_BASE_PTR->CNT = 0U;
+            break;
+        case BOARD_WDOG_MODE_FCCU: /* fccu */
+            /* Drive WDOG_ANY from FCCU */
+            IOMUXC_SetPinMux(IOMUXC_PAD_WDOG_ANY__FCCU_EOUT1, 0U);
+
+            /* Disallow WDOG to generate internal warm reset */
+            SRC_GEN->SRMASK |= BOARD_WDOG_SRMASK;
+
+            /* Disable WDOG interrupt */
+            NVIC_DisableIRQ(BOARD_WDOG_IRQn);
+            break;
+        default:
+            ; /* Intentional empty default */
+            break;
+    }
+}
+
+/*--------------------------------------------------------------------------*/
+/* Kick the watchdog timer                                                  */
+/*--------------------------------------------------------------------------*/
+void BOARD_WdogRefresh(void)
+{
+    WDOG32_Refresh(BOARD_WDOG_BASE_PTR);
+}
+
+/*--------------------------------------------------------------------------*/
+/* Initialize serial bus for external devices                               */
+/*--------------------------------------------------------------------------*/
+void BOARD_InitSerialBus(void)
+{
+    static LPI2C_Type *const s_i2cBases[] = LPI2C_BASE_PTRS;
+    LPI2C_Type *base = s_i2cBases[BOARD_I2C_INSTANCE];
+    lpi2c_master_config_t lpi2cConfig = {0};
+    static uint32_t const s_i2cClks[] =
+    {
+        0U,
+        CLOCK_ROOT_LPI2C1,
+        CLOCK_ROOT_LPI2C2
+    };
+    uint32_t clockId = s_i2cClks[BOARD_I2C_INSTANCE];
+
+    uint32_t rate = U64_U32(CCM_RootGetRate(clockId));
+
+    LPI2C_MasterGetDefaultConfig(&lpi2cConfig);
+
+    lpi2cConfig.baudRate_Hz = BOARD_I2C_BAUDRATE;
+    lpi2cConfig.enableDoze = false;
+
+    LPI2C_MasterInit(base, &lpi2cConfig, rate);
+}
+
+/*--------------------------------------------------------------------------*/
+/* System sleep prepare                                                     */
+/*--------------------------------------------------------------------------*/
+void BOARD_SystemSleepPrepare(uint32_t sleepMode, uint32_t sleepFlags)
+{
+    BRD_SM_VoltageSuspend(true);
+
+    /* Configure SM LPUART for wakeup */
+    if (s_uartConfig.base != NULL)
+    {
+        /* Enable edge-detect IRQ */
+        (void) LPUART_ClearStatusFlags(s_uartConfig.base,
+            (uint32_t)kLPUART_RxActiveEdgeFlag);
+        LPUART_EnableInterrupts(s_uartConfig.base,
+            (uint32_t)kLPUART_RxActiveEdgeInterruptEnable);
+        NVIC_EnableIRQ(s_uartConfig.irq);
+
+        /* Configure LPI of SM LPUART */
+        (void) CPU_PerLpiConfigSet(CPU_IDX_M33P, s_uartConfig.perLpiId,
+            CPU_PER_LPI_ON_RUN_WAIT_STOP);
+    }
+
+    /* Configure LPI for GPIO1 */
+    (void) CPU_PerLpiConfigSet(CPU_IDX_M33P, CPU_PER_LPI_IDX_GPIO1,
+        CPU_PER_LPI_ON_RUN_WAIT_STOP);
+}
+
+/*--------------------------------------------------------------------------*/
+/* System sleep entry                                                       */
+/*--------------------------------------------------------------------------*/
+void BOARD_SystemSleepEnter(uint32_t sleepMode, uint32_t sleepFlags)
+{
+    /* Disable SysTick */
+    uint32_t sysTickMask = SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
+    SysTick->CTRL &= (~sysTickMask);
+
+    /* Clear pending SysTick exception */
+    SCB->ICSR = SCB_ICSR_PENDSTCLR_Msk;
+
+    if (s_wdogConfig.enableWdog32)
+    {
+        /* Disable WDOG */
+        WDOG32_Deinit(BOARD_WDOG_BASE_PTR);
+
+        /* Waits for new configuration to take effect. */
+        while (0U == ((BOARD_WDOG_BASE_PTR->CS) & WDOG_CS_RCS_MASK))
+        {
+            ; /* Intentional empty while */
+        }
+    }
+}
+
+/*--------------------------------------------------------------------------*/
+/* System sleep exit                                                        */
+/*--------------------------------------------------------------------------*/
+void BOARD_SystemSleepExit(uint32_t sleepMode, uint32_t sleepFlags)
+{
+    if (s_wdogConfig.enableWdog32)
+    {
+        /* Enable WDOG */
+        WDOG32_Init(BOARD_WDOG_BASE_PTR, &s_wdogConfig);
+    }
+
+    /* Enable SysTick */
+    uint32_t sysTickMask = SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
+    SysTick->VAL   = 0U;
+    SysTick->CTRL |= (sysTickMask);
+}
+
+/*--------------------------------------------------------------------------*/
+/* System sleep unprepare                                                   */
+/*--------------------------------------------------------------------------*/
+void BOARD_SystemSleepUnprepare(uint32_t sleepMode, uint32_t sleepFlags)
+{
+    BRD_SM_VoltageRestore();
+
+    /* Service SM LPUART wakeup events */
+    if (s_uartConfig.base != NULL)
+    {
+        (void) LPUART_ClearStatusFlags(s_uartConfig.base,
+            (uint32_t)kLPUART_RxActiveEdgeFlag);
+        LPUART_DisableInterrupts(s_uartConfig.base,
+            (uint32_t)kLPUART_RxActiveEdgeInterruptEnable);
+
+        NVIC_DisableIRQ(s_uartConfig.irq);
+        NVIC_ClearPendingIRQ(s_uartConfig.irq);
+    }
+}
+
diff --git a/boards/ccimx95dvk/board.h b/boards/ccimx95dvk/board.h
new file mode 100755
index 000000000000..d6b450b92f10
--- /dev/null
+++ b/boards/ccimx95dvk/board.h
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2023-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef BOARD_H
+#define BOARD_H
+
+#include "fsl_common.h"
+#include "config_board.h"
+#include "dev_sm.h"
+
+/*!
+ * @addtogroup BRD_SM_MX95EVK
+ * @{
+ *
+ * @file
+ * @brief
+ *
+ * Header file containing the board API.
+ */
+
+/*******************************************************************************
+ * Definitions
+ ******************************************************************************/
+
+/*!
+ * @name Board general parameters
+ */
+/** @{ */
+#define BOARD_TICK_PERIOD_MSEC  10U                       /*!< Tick period */
+#define BOARD_SWI_IRQn          Reserved110_IRQn          /*!< SWI IRQ */
+#define BOARD_HAS_WDOG                                    /*!< Has a watchdog */
+#define BOARD_HAS_PMIC                                    /*!< Has a PMIC */
+#define BOARD_PMIC_RESUME_TICKS ((20U * 32768U) / 10000U) /*!< 2ms in 32K ticks */
+/** @} */
+
+/*!
+ * @name Board PF09 OTP voltages (uV)
+ */
+/** @{ */
+#define BOARD_VOLT_SOC  920000  /*!< SOC OTP */
+#define BOARD_VOLT_ARM  920000  /*!< ARM OTP */
+/** @} */
+
+/*!
+ * @name Watchdog modes
+ */
+/** @{ */
+#define BOARD_WDOG_MODE_WARM     0U  /*!< Wdog generate warm reset */
+#define BOARD_WDOG_MODE_COLD     1U  /*!< Wdog generate cold reset */
+#define BOARD_WDOG_MODE_IRQ      2U  /*!< Wdog generate IRQ only */
+#define BOARD_WDOG_MODE_OFF      3U  /*!< Wdog disabled */
+#define BOARD_WDOG_MODE_TRIGGER  4U  /*!< Trigger wdog */
+#define BOARD_WDOG_MODE_FCCU     5U  /*!< Wdog generate FCCU fault */
+/** @} */
+
+/*******************************************************************************
+ * Types
+ ******************************************************************************/
+
+/*!
+ * Debug UART configuration info
+ */
+typedef struct
+{
+    LPUART_Type *const base;  /*!< LPUART base pointer */
+    IRQn_Type irq;            /*!< Interrupt number */
+    uint32_t clockId;         /*!< Clock ID */
+    uint32_t perLpiId;        /*!< Peripheral LPI ID */
+    uint32_t baud;            /*!< Baud rate */
+    uint8_t inst;             /*!< Instance number */
+} board_uart_config_t;
+
+#if defined(__cplusplus)
+extern "C" {
+#endif /* __cplusplus */
+
+/*******************************************************************************
+ * API
+ ******************************************************************************/
+
+/*! Configure the M33 MPU */
+void BOARD_ConfigMPU(void);
+
+/*! Init hardware */
+void BOARD_InitHardware(void);
+
+/*! Init clocks */
+void BOARD_InitClocks(void);
+
+/*!
+ * Get a device clock debug UART info.
+ *
+ * This function returns the UART info for the UART used for SM
+ * debug.
+ *
+ * @return Returns the debug UART config info.
+ */
+const board_uart_config_t *BOARD_GetDebugUart(void);
+
+/*! Init the debug UART */
+void BOARD_InitDebugConsole(void);
+
+/*! Init interrupt handlers */
+void BOARD_InitHandlers(void);
+
+/*! Init timers */
+void BOARD_InitTimers(void);
+
+/*! Init serial buses */
+void BOARD_InitSerialBus(void);
+
+/*!
+ * Board-level prepare for system sleep entry
+ *
+ * @param sleepMode  Sleep mode being entered.
+ * @param sleepFlags Sleep flag options.
+ */
+void BOARD_SystemSleepPrepare(uint32_t sleepMode, uint32_t sleepFlags);
+
+/*!
+ * Board-level system sleep entry
+ *
+ * @param sleepMode  Sleep mode being entered.
+ * @param sleepFlags Sleep flag options.
+ */
+void BOARD_SystemSleepEnter(uint32_t sleepMode, uint32_t sleepFlags);
+
+/*!
+ * Board-level system sleep exit
+ *
+ * @param sleepMode  Sleep mode being exited.
+ * @param sleepFlags Sleep flag options.
+ */
+void BOARD_SystemSleepExit(uint32_t sleepMode, uint32_t sleepFlags);
+
+/*!
+ * Board-level unprepare for system sleep entry
+ *
+ * @param sleepMode  Sleep mode being entered.
+ * @param sleepFlags Sleep flag options.
+ */
+void BOARD_SystemSleepUnprepare(uint32_t sleepMode, uint32_t sleepFlags);
+
+/*!
+ * Set the watchdog mode
+ *
+ * @param mode Mode to set.
+ */
+void BOARD_WdogModeSet(uint32_t mode);
+
+/*! Service the watchdog */
+void BOARD_WdogRefresh(void);
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+/** @} */
+
+#endif /* BOARD_H */
+
diff --git a/boards/ccimx95dvk/pin_mux.c b/boards/ccimx95dvk/pin_mux.c
new file mode 100755
index 000000000000..b40d897fbcdc
--- /dev/null
+++ b/boards/ccimx95dvk/pin_mux.c
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2023 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include "pin_mux.h"
+#include "board.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void)
+{
+#if (BOARD_DEBUG_UART_INSTANCE == 1U)
+    /* Configure LPUART 1 */
+    IOMUXC_SetPinMux(IOMUXC_PAD_UART1_RXD__LPUART1_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_UART1_RXD__LPUART1_RX, IOMUXC_PAD_PD(1U));
+
+    IOMUXC_SetPinMux(IOMUXC_PAD_UART1_TXD__LPUART1_TX, 0);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_UART1_TXD__LPUART1_TX, IOMUXC_PAD_DSE(0xFU));
+#elif (BOARD_DEBUG_UART_INSTANCE == 2U)
+    /* Configure LPUART 2 */
+    IOMUXC_SetPinMux(IOMUXC_PAD_UART2_RXD__LPUART2_RX, 0);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_UART2_RXD__LPUART2_RX, IOMUXC_PAD_PD(1U));
+
+    IOMUXC_SetPinMux(IOMUXC_PAD_UART2_TXD__LPUART2_TX, 0);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_UART2_TXD__LPUART2_TX, IOMUXC_PAD_DSE(0xFU));
+#endif
+
+#if (BOARD_I2C_INSTANCE == 1U)
+    /* Configure LPI2C 1 */
+    IOMUXC_SetPinMux(IOMUXC_PAD_I2C1_SCL__LPI2C1_SCL, 1U);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_I2C1_SCL__LPI2C1_SCL, IOMUXC_PAD_DSE(0xFU)
+        | IOMUXC_PAD_FSEL1(0x3U) | IOMUXC_PAD_PU(0x1U) | IOMUXC_PAD_OD(0x1U));
+
+    IOMUXC_SetPinMux(IOMUXC_PAD_I2C1_SDA__LPI2C1_SDA, 1U);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_I2C1_SDA__LPI2C1_SDA, IOMUXC_PAD_DSE(0xFU)
+        | IOMUXC_PAD_FSEL1(0x3U) | IOMUXC_PAD_PU(0x1U) | IOMUXC_PAD_OD(0x1U));
+#elif (BOARD_I2C_INSTANCE == 2U)
+    /* Configure LPI2C 2 */
+    IOMUXC_SetPinMux(IOMUXC_PAD_I2C2_SCL__LPI2C2_SCL, 1U);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_I2C2_SCL__LPI2C2_SCL, IOMUXC_PAD_DSE(0xFU)
+        | IOMUXC_PAD_FSEL1(0x3U) | IOMUXC_PAD_PU(0x1U) | IOMUXC_PAD_OD(0x1U));
+
+    IOMUXC_SetPinMux(IOMUXC_PAD_I2C2_SDA__LPI2C2_SDA, 1U);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_I2C2_SDA__LPI2C2_SDA, IOMUXC_PAD_DSE(0xFU)
+        | IOMUXC_PAD_FSEL1(0x3U) | IOMUXC_PAD_PU(0x1U) | IOMUXC_PAD_OD(0x1U));
+#endif
+
+    /* Configure GPIO1-10 (INT from the PCAL6408A */
+    IOMUXC_SetPinMux(IOMUXC_PAD_PDM_BIT_STREAM1__GPIO1_IO_BIT10, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_PDM_BIT_STREAM1__GPIO1_IO_BIT10, 0U);
+}
+
diff --git a/boards/ccimx95dvk/pin_mux.h b/boards/ccimx95dvk/pin_mux.h
new file mode 100755
index 000000000000..24cd7920d220
--- /dev/null
+++ b/boards/ccimx95dvk/pin_mux.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2023 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PIN_MUX_H
+#define PIN_MUX_H
+
+#include "fsl_iomuxc.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup BRD_SM_MX95EVK
+ * @file
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void); /*!< Function assigned for the core: Cortex-M33[cm33] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* PIN_MUX_H */
+
diff --git a/boards/ccimx95dvk/sm/Makefile b/boards/ccimx95dvk/sm/Makefile
new file mode 100755
index 000000000000..d5b576737636
--- /dev/null
+++ b/boards/ccimx95dvk/sm/Makefile
@@ -0,0 +1,70 @@
+## ###################################################################
+##
+## Copyright 2023 NXP
+##
+## Redistribution and use in source and binary forms, with or without modification,
+## are permitted provided that the following conditions are met:
+##
+## o Redistributions of source code must retain the above copyright notice, this list
+##   of conditions and the following disclaimer.
+##
+## o Redistributions in binary form must reproduce the above copyright notice, this
+##   list of conditions and the following disclaimer in the documentation and/or
+##   other materials provided with the distribution.
+##
+## o Neither the name of the copyright holder nor the names of its
+##   contributors may be used to endorse or promote products derived from this
+##   software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+## ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+## WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+## DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+## ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+## ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+## (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+## SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+##
+##
+## ###################################################################
+
+BOARD ?= mcimx95evk
+BRD_SM_API_DIR = $(ROOT_DIR)/sm/brd
+BOARDS_DIR = $(ROOT_DIR)/boards
+BOARD_DIR = $(BOARDS_DIR)/$(BOARD)
+
+INCLUDE +=  \
+	-I$(BRD_SM_API_DIR)  \
+	-I$(BOARDS_DIR)  \
+	-I$(BOARD_DIR)  \
+	-I$(BOARD_DIR)/sm \
+	-I$(COMPONENTS_DIR)/pcal6408a  \
+	-I$(COMPONENTS_DIR)/pf09  \
+	-I$(COMPONENTS_DIR)/pf53  \
+	-I$(COMPONENTS_DIR)/pca2131
+
+VPATH +=  \
+	$(BRD_SM_API_DIR)  \
+	$(BOARDS_DIR)  \
+	$(BOARD_DIR)  \
+	$(BOARD_DIR)/sm  \
+	$(COMPONENTS_DIR)/pcal6408a  \
+	$(COMPONENTS_DIR)/pf09  \
+	$(COMPONENTS_DIR)/pf53  \
+	$(COMPONENTS_DIR)/pca2131
+
+OBJS += \
+	$(OUT)/board.o  \
+	$(OUT)/brd_sm.o  \
+	$(OUT)/brd_sm_handlers.o  \
+	$(OUT)/brd_sm_control.o  \
+	$(OUT)/brd_sm_sensor.o  \
+	$(OUT)/brd_sm_voltage.o  \
+	$(OUT)/brd_sm_bbm.o  \
+	$(OUT)/fsl_pcal6408a.o  \
+	$(OUT)/fsl_pf09.o  \
+	$(OUT)/fsl_pf53.o  \
+	$(OUT)/fsl_pca2131.o
+
diff --git a/boards/ccimx95dvk/sm/brd_sm.c b/boards/ccimx95dvk/sm/brd_sm.c
new file mode 100755
index 000000000000..cd48b590cd26
--- /dev/null
+++ b/boards/ccimx95dvk/sm/brd_sm.c
@@ -0,0 +1,665 @@
+/*
+** ###################################################################
+**
+** Copyright 2023-2025 NXP
+**
+** Redistribution and use in source and binary forms, with or without modification,
+** are permitted provided that the following conditions are met:
+**
+** o Redistributions of source code must retain the above copyright notice, this list
+**   of conditions and the following disclaimer.
+**
+** o Redistributions in binary form must reproduce the above copyright notice, this
+**   list of conditions and the following disclaimer in the documentation and/or
+**   other materials provided with the distribution.
+**
+** o Neither the name of the copyright holder nor the names of its
+**   contributors may be used to endorse or promote products derived from this
+**   software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+** LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+** ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**
+** ###################################################################
+*/
+
+/*==========================================================================*/
+/* File containing the implementation of the SM abstraction for the board.  */
+/*==========================================================================*/
+
+/* Includes */
+
+#include "sm.h"
+#include "brd_sm.h"
+#include "dev_sm.h"
+#include "lmm.h"
+#include "fsl_lpi2c.h"
+#include "fsl_bbnsm.h"
+#include "fsl_rgpio.h"
+#include "fsl_iomuxc.h"
+
+/* Local defines */
+
+#define BRD_SM_RST_REC_FIRST  4U     /* First GPR for shutdown record */
+#define BRD_SM_RST_REC_NUM    4U     /* Number of GPR for shutdown record */
+
+/* Defines to encode the reason */
+#define BRD_SM_REC_REASON_MASK  (0x000000FFU)
+#define BRD_SM_REC_REASON_SHIFT (0U)
+#define BRD_SM_REC_REASON(x) \
+    (((uint32_t)(((uint32_t)(x)) << BRD_SM_REC_REASON_SHIFT)) & \
+    BRD_SM_REC_REASON_MASK)
+
+/* Defines to encode the error ID */
+#define BRD_SM_REC_EID_MASK  (0x007FFF00U)
+#define BRD_SM_REC_EID_SHIFT (8U)
+#define BRD_SM_REC_EID(x) \
+    (((uint32_t)(((uint32_t)(x)) << BRD_SM_REC_EID_SHIFT)) & \
+    BRD_SM_REC_EID_MASK)
+#define BRD_SM_REC_EID_SIGN  (0x00004000U)
+#define BRD_SM_REC_EID_EXT   (0xFFFF8000U)
+
+/* Defines to encode the valid flag for the errId */
+#define BRD_SM_REC_VERR_MASK  (0x00800000U)
+#define BRD_SM_REC_VERR_SHIFT (23U)
+#define BRD_SM_REC_VERR(x) \
+    (((uint32_t)(((uint32_t)(x)) << BRD_SM_REC_VERR_SHIFT)) & \
+    BRD_SM_REC_VERR_MASK)
+
+/* Defines to encode the source/origin */
+#define BRD_SM_REC_SRC_MASK  (0x0F000000U)
+#define BRD_SM_REC_SRC_SHIFT (24U)
+#define BRD_SM_REC_SRC(x) \
+    (((uint32_t)(((uint32_t)(x)) << BRD_SM_REC_SRC_SHIFT)) & \
+    BRD_SM_REC_SRC_MASK)
+
+/* Defines to encode the valid flag for the source */
+#define BRD_SM_REC_VSRC_MASK  (0x10000000U)
+#define BRD_SM_REC_VSRC_SHIFT (28U)
+#define BRD_SM_REC_VSRC(x) \
+    (((uint32_t)(((uint32_t)(x)) << BRD_SM_REC_VSRC_SHIFT)) & \
+    BRD_SM_REC_VSRC_MASK)
+
+/* Defines to encode the extended info length */
+#define BRD_SM_REC_LEN_MASK  (0x60000000U)
+#define BRD_SM_REC_LEN_SHIFT (29U)
+#define BRD_SM_REC_LEN(x) \
+    (((uint32_t)(((uint32_t)(x)) << BRD_SM_REC_LEN_SHIFT)) & \
+    BRD_SM_REC_LEN_MASK)
+
+/* Defines to encode the valid */
+#define BRD_SM_REC_VLD_MASK  (0x80000000U)
+#define BRD_SM_REC_VLD_SHIFT (31U)
+#define BRD_SM_REC_VLD(x) \
+    (((uint32_t)(((uint32_t)(x)) << BRD_SM_REC_VLD_SHIFT)) & \
+    BRD_SM_REC_VLD_MASK)
+
+/* Performance parameters */
+#define BOARD_PERF_LEVEL  DEV_SM_PERF_LVL_ODV  /* Target perf level */
+#if BOARD_VOLT_SOC >= ES_ODV_UV_VDD_SOC
+#define BOARD_BOOT_LEVEL  DEV_SM_PERF_LVL_ODV  /* Boot perf overdrive */
+#elif BOARD_VOLT_SOC >= ES_NOM_UV_VDD_SOC
+#define BOARD_BOOT_LEVEL  DEV_SM_PERF_LVL_NOM  /* Boot perf nominal */
+#else
+#define BOARD_BOOT_LEVEL  DEV_SM_PERF_LVL_LOW  /* Boot perf low */
+#endif
+
+/* Local types */
+
+/* Local variables */
+
+/* Local functions */
+
+static int32_t BRD_SM_InitComplete(uint32_t mSel);
+
+/*--------------------------------------------------------------------------*/
+/* Init board                                                               */
+/*--------------------------------------------------------------------------*/
+// coverity[misra_c_2012_directive_4_6_violation:FALSE]
+int32_t BRD_SM_Init(int argc, const char * const argv[], uint32_t *mSel)
+{
+    int32_t status;
+    uint64_t addr;
+    uint32_t ms;
+    uint32_t flags;
+
+    /* Init board hardware */
+    BOARD_InitHardware();
+
+    /* Get the boot mode select */
+    if (DEV_SM_RomBootCpuGet(DEV_SM_CPU_M33P, &addr, &ms, &flags)
+        == SM_ERR_SUCCESS)
+    {
+        *mSel = ms;
+    }
+
+    /* Initialize devices connected to serial buses (PMIC, IOExp, etc) */
+    status = BRD_SM_SerialDevicesInit();
+
+    if (status == SM_ERR_SUCCESS)
+    {
+        /* Init the device */
+        status = DEV_SM_Init(BOARD_BOOT_LEVEL, BOARD_PERF_LEVEL);
+    }
+
+    if (status == SM_ERR_SUCCESS)
+    {
+        /* Complete board init after device init */
+        status = BRD_SM_InitComplete(*mSel);
+    }
+
+    if (status == SM_ERR_SUCCESS)
+    {
+        /* Disallow ANA TMPSNS to generate internal warm reset */
+        SRC_GEN->SRMASK |= BIT32(RST_REASON_TEMPSENSE);
+
+        /* Switch WDOG to FCCU mode */
+        BOARD_WdogModeSet(BOARD_WDOG_MODE_FCCU);
+    }
+
+    /* TODO: Remove when A0 support dropped */
+    /* Configure ISO controls based on feature fuses */
+    uint32_t ipIsoMask = 0U;
+
+    /* PCIe1 is tied to HSIO ISO[0] */
+    if (DEV_SM_FuseGet(DEV_SM_FUSE_PCIE1_DISABLE) == 0U)
+    {
+        ipIsoMask |= SRC_XSPR_SLICE_SW_CTRL_ISO_CTRL_0_MASK;
+    }
+
+    /* PCIe2 is tied to HSIO ISO[1] */
+    if (DEV_SM_FuseGet(DEV_SM_FUSE_PCIE2_DISABLE) == 0U)
+    {
+        ipIsoMask |= SRC_XSPR_SLICE_SW_CTRL_ISO_CTRL_1_MASK;
+    }
+
+    /* Apply ISO mask */
+    if (ipIsoMask != 0U)
+    {
+        SRC_XSPR_HSIOMIX_TOP->SLICE_SW_CTRL &= (~ipIsoMask);
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Exit function                                                            */
+/*--------------------------------------------------------------------------*/
+_Noreturn void BRD_SM_Exit(int32_t status, uint32_t pc)
+{
+#if defined(MONITOR) || defined(RUN_TEST)
+    printf("exit %d, 0x%08X\n", status, pc);
+
+    /* Disable watchdog */
+    BOARD_WdogModeSet(BOARD_WDOG_MODE_OFF);
+#else
+    SM_SYSTEMERROR(status, pc);
+    // coverity[misra_c_2012_rule_2_2_violation:FALSE]
+    SystemExit();
+#endif
+
+    /* Hang */
+    // coverity[infinite_loop:FALSE]
+    while (true)
+    {
+        ; /* Intentional empty while */
+    }
+}
+
+/*--------------------------------------------------------------------------*/
+/* Board timer tick                                                         */
+/*--------------------------------------------------------------------------*/
+void BRD_SM_TimerTick(uint32_t msec)
+{
+    /* Kick the dog */
+    BOARD_WdogRefresh();
+}
+
+/*--------------------------------------------------------------------------*/
+/* Custom monitor function                                                  */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_Custom(int32_t argc, const char * const argv[])
+{
+    return SM_ERR_SUCCESS;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Get fault reaction                                                       */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_FaultReactionGet(dev_sm_rst_rec_t resetRec,
+    // coverity[misra_c_2012_rule_8_13_violation:FALSE]
+    uint32_t *reaction, uint32_t *lm)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Print reaction */
+    switch (*reaction)
+    {
+        case LMM_REACT_SYS_RESET:
+        case LMM_REACT_SYS_SHUTDOWN:
+            ; /* Intentional empty as will print elsewhere */
+            break;
+        case LMM_REACT_GRP_RESET:
+            printf("\nReset group %u", *lm);
+            BRD_SM_ResetRecordPrint(",", resetRec);
+            break;
+        case LMM_REACT_GRP_SHUTDOWN:
+            printf("\nShutdown group %u", *lm);
+            BRD_SM_ResetRecordPrint(",", resetRec);
+            break;
+        case LMM_REACT_LM_RESET:
+            printf("\nReset LM %u", *lm);
+            BRD_SM_ResetRecordPrint(",", resetRec);
+            break;
+        case LMM_REACT_LM_SHUTDOWN:
+            printf("\nShutdown LM %u", *lm);
+            BRD_SM_ResetRecordPrint(",", resetRec);
+            break;
+        case LMM_REACT_BOARD:
+            printf("\nBoard %u", *lm);
+            BRD_SM_ResetRecordPrint(",", resetRec);
+            break;
+        case LMM_REACT_FUSA:
+            printf("\nFuSa %u", *lm);
+            BRD_SM_ResetRecordPrint(",", resetRec);
+            break;
+        case LMM_REACT_NONE:
+            ; /* Intentional empty case */
+            break;
+        default:
+            status = SM_ERR_INVALID_PARAMETERS;
+            break;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Custom fault handler                                                     */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_CustomFault(dev_sm_rst_rec_t resetRec, uint32_t lm)
+{
+    /* Return status */
+    return SM_ERR_SUCCESS;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Print reset record                                                       */
+/*--------------------------------------------------------------------------*/
+void BRD_SM_ResetRecordPrint(string name, dev_sm_rst_rec_t resetRec)
+{
+    if (resetRec.valid)
+    {
+        int32_t status;
+        string reasonNameAddr;
+
+        /* Get name */
+        status = LMM_SystemReasonNameGet(0U, resetRec.reason,
+            &reasonNameAddr, NULL);
+
+        /* Print reason */
+        printf("%s reason=", name);
+        if (status == SM_ERR_SUCCESS)
+        {
+            printf("%s", reasonNameAddr);
+        }
+        else
+        {
+            printf("%u", resetRec.reason);
+        }
+        if (resetRec.validErr)
+        {
+            printf(", errId=%d", (int32_t) resetRec.errId);
+        }
+        if (resetRec.validOrigin)
+        {
+            printf(", srcLm=%u", resetRec.origin);
+        }
+        printf("\n");
+
+        /* Print extended info */
+        for (uint32_t ex = 0U; ex < resetRec.extLen; ex++)
+        {
+            printf("  0x%08X\n", resetRec.extInfo[ex]);
+        }
+    }
+}
+
+/*--------------------------------------------------------------------------*/
+/* Load and clear persistent shutdown record of previous boot               */
+/*--------------------------------------------------------------------------*/
+void BRD_SM_ShutdownRecordLoad(dev_sm_rst_rec_t *shutdownRec)
+{
+#if BRD_SM_RST_REC_NUM > 0
+    uint32_t hdr = 0U;
+    uint32_t *ePtr = &(shutdownRec->extInfo[0]);
+
+    /* Read and clear header */
+    (void) BBNSM_GprGetValue(BBNSM, BRD_SM_RST_REC_FIRST, &hdr);
+    (void) BBNSM_GprSetValue(BBNSM, BRD_SM_RST_REC_FIRST, 0U);
+
+    /* Valid? */
+    if (((hdr & BRD_SM_REC_VLD_MASK ) >> BRD_SM_REC_VLD_SHIFT) != 0U)
+    {
+        shutdownRec->valid = true;
+
+        /* Parse header */
+        shutdownRec->reason = (hdr & BRD_SM_REC_REASON_MASK ) >>
+            BRD_SM_REC_REASON_SHIFT;
+        shutdownRec->errId = (hdr & BRD_SM_REC_EID_MASK ) >>
+            BRD_SM_REC_EID_SHIFT;
+        shutdownRec->validErr = ((hdr & BRD_SM_REC_VERR_MASK ) != 0U);
+        shutdownRec->origin = (hdr & BRD_SM_REC_SRC_MASK ) >>
+            BRD_SM_REC_SRC_SHIFT;
+        shutdownRec->validOrigin = ((hdr & BRD_SM_REC_VSRC_MASK ) != 0U);
+        shutdownRec->extLen = (hdr & BRD_SM_REC_LEN_MASK ) >>
+            BRD_SM_REC_LEN_SHIFT;
+
+        /* Sign extend */
+        if ((shutdownRec->errId & BRD_SM_REC_EID_SIGN) != 0U)
+        {
+            shutdownRec->errId |= BRD_SM_REC_EID_EXT;
+        }
+
+        shutdownRec->extLen = MIN(shutdownRec->extLen, DEV_SM_NUM_EXT_INFO);
+    }
+
+    /* Copy out extended info */
+    for (uint8_t idx = 1U; idx < BRD_SM_RST_REC_NUM; idx++)
+    {
+        if (idx <= shutdownRec->extLen)
+        {
+            (void) BBNSM_GprGetValue(BBNSM, idx + BRD_SM_RST_REC_FIRST,
+                ePtr);
+            ePtr++;
+        }
+        else
+        {
+            break;
+        }
+    }
+#endif
+
+    /* PMIC reset? */
+    if ((g_pmicFaultFlags & (PF09_XFAIL_FLG | PF09_WD_FLG
+        | PF09_HFAULT_FLG)) != 0U)
+    {
+        shutdownRec->valid = true;
+        shutdownRec->reset = true;
+        shutdownRec->reason = DEV_SM_REASON_PMIC;
+        shutdownRec->validErr = false;
+        shutdownRec->validOrigin = false;
+        shutdownRec->extLen = 1U;
+        shutdownRec->extInfo[0] = g_pmicFaultFlags;
+    }
+}
+
+/*--------------------------------------------------------------------------*/
+/* Save shutdown record to persistent storage                               */
+/*--------------------------------------------------------------------------*/
+void BRD_SM_ShutdownRecordSave(dev_sm_rst_rec_t shutdownRec)
+{
+#if BRD_SM_RST_REC_NUM > 0
+    uint32_t hdr;
+    const uint32_t *ePtr = &(shutdownRec.extInfo[0]);
+
+    /* Store extended info */
+    for (uint8_t idx = 1U; idx < BRD_SM_RST_REC_NUM; idx++)
+    {
+        if (idx <= shutdownRec.extLen)
+        {
+            (void) BBNSM_GprSetValue(BBNSM, idx + BRD_SM_RST_REC_FIRST,
+                *ePtr);
+            ePtr++;
+        }
+        else
+        {
+            break;
+        }
+    }
+
+    /* Create header */
+    hdr = BRD_SM_REC_REASON(shutdownRec.reason)
+        | BRD_SM_REC_EID(shutdownRec.errId)
+        | BRD_SM_REC_VERR(shutdownRec.validErr ? 1U : 0U)
+        | BRD_SM_REC_SRC(shutdownRec.origin)
+        | BRD_SM_REC_VSRC(shutdownRec.validOrigin ? 1U : 0U)
+        | BRD_SM_REC_LEN(shutdownRec.extLen)
+        | BRD_SM_REC_VLD(shutdownRec.valid ? 1U : 0U);
+
+    /* Save header */
+    (void) BBNSM_GprSetValue(BBNSM, BRD_SM_RST_REC_FIRST, hdr);
+#endif
+
+    /* Print shutdown record */
+    if (shutdownRec.reset)
+    {
+        BRD_SM_ResetRecordPrint("\nReset request:", shutdownRec);
+    }
+    else
+    {
+        BRD_SM_ResetRecordPrint("\nShutdown request:", shutdownRec);
+    }
+}
+
+/*--------------------------------------------------------------------------*/
+/* Reset board                                                              */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_SystemReset(void)
+{
+    int32_t status = SM_ERR_SUCCESS;
+    rgpio_pin_config_t gpioConfig =
+    {
+        kRGPIO_DigitalOutput,
+        0U
+    };
+
+    /* Drive WDOG_ANY to reset PMIC */
+    RGPIO_PinInit(GPIO1, 15U, &gpioConfig);
+    IOMUXC_SetPinMux(IOMUXC_PAD_WDOG_ANY__GPIO1_IO_BIT15, 0U);
+
+    /* Wait for PMIC to react */
+    SystemTimeDelay(1000U);
+
+    /* Fall back to warm reset of the device */
+    status = DEV_SM_SystemReset();
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Get PMIC info                                                            */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_PmicInfoGet(uint32_t idx, uint8_t *devAddr, uint8_t **info,
+    uint8_t *len)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Call PMIC driver to get info */
+    switch (idx)
+    {
+        case 0U:
+            *devAddr = g_pf09Dev.devAddr;
+            if (!PF09_PmicInfoGet(&g_pf09Dev, info, len))
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+            break;
+        case 1U:
+            *devAddr = g_pf5301Dev.devAddr;
+            if (!PF53_PmicInfoGet(&g_pf5301Dev, info, len))
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+            break;
+        case 2U:
+            *devAddr = g_pf5302Dev.devAddr;
+            if (!PF53_PmicInfoGet(&g_pf5302Dev, info, len))
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+            break;
+        default:
+            status = SM_ERR_NOT_FOUND;
+            break;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* PMIC register write                                                      */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_PmicWrite(uint8_t devAddr, uint8_t regAddr, uint8_t val,
+    uint8_t mask)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Call PF09 driver write data */
+    if (devAddr == g_pf09Dev.devAddr)
+    {
+        if (!PF09_PmicWrite(&g_pf09Dev, regAddr, val, mask))
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+    /* Call PF5301 driver write data */
+    else if (devAddr == g_pf5301Dev.devAddr)
+    {
+        if (!PF53_PmicWrite(&g_pf5301Dev, regAddr, val, mask))
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+    /* Call PF5302 driver write data */
+    else if (devAddr == g_pf5302Dev.devAddr)
+    {
+        if (!PF53_PmicWrite(&g_pf5302Dev, regAddr, val, mask))
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+    /* Invalid device address */
+    else
+    {
+        status = SM_ERR_NOT_FOUND;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* PMIC register read                                                       */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_PmicRead(uint8_t devAddr, uint8_t regAddr, uint8_t *val)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Call PF09 driver read data */
+    if (devAddr == g_pf09Dev.devAddr)
+    {
+        if (!PF09_PmicRead(&g_pf09Dev, regAddr, val))
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+    /* Call PF5301 driver read data */
+    else if (devAddr == g_pf5301Dev.devAddr)
+    {
+        if (!PF53_PmicRead(&g_pf5301Dev, regAddr, val))
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+    /* Call PF5302 driver read data */
+    else if (devAddr == g_pf5302Dev.devAddr)
+    {
+        if (!PF53_PmicRead(&g_pf5302Dev, regAddr, val))
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+    /* Invalid device address */
+    else
+    {
+        status = SM_ERR_NOT_FOUND;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Set mode of specified SoC supply                                         */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_SupplyModeSet(uint32_t domain, uint8_t voltMode)
+{
+    /* Set voltage mode */
+    return BRD_SM_VoltageModeSet(domain, voltMode);
+}
+
+/*--------------------------------------------------------------------------*/
+/* Get mode of specified SoC supply                                         */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_SupplyModeGet(uint32_t domain, uint8_t *voltMode)
+{
+    /* Get voltage mode */
+    return BRD_SM_VoltageModeGet(domain, voltMode);
+}
+
+/*--------------------------------------------------------------------------*/
+/* Set voltage of specified SoC supply                                      */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_SupplyLevelSet(uint32_t domain, int32_t microVolt)
+{
+    int32_t status = SM_ERR_INVALID_PARAMETERS;
+
+    /* Check for wrap */
+    if (microVolt <= (INT32_MAX - BOARD_PERF_VDROP))
+    {
+        /* Set voltage level */
+        status = BRD_SM_VoltageLevelSet(domain, microVolt
+            + BOARD_PERF_VDROP);
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Get voltage of specified SoC supply                                      */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_SupplyLevelGet(uint32_t domain, int32_t *microVolt)
+{
+    /* Get voltage level */
+    return BRD_SM_VoltageLevelGet(domain, microVolt);
+}
+
+/*==========================================================================*/
+
+/*--------------------------------------------------------------------------*/
+/* Complete init after DEV_SM init                                          */
+/*--------------------------------------------------------------------------*/
+static int32_t BRD_SM_InitComplete(uint32_t mSel)
+{
+    /* Safe to call DEV_SM functions to init hardware. For example, to
+       enabled a power domain, configure a clock SSC, clock rate, or pin.
+       Not safe to call LMM functions! */
+
+    return SM_ERR_SUCCESS;
+}
+
diff --git a/boards/ccimx95dvk/sm/brd_sm.dox b/boards/ccimx95dvk/sm/brd_sm.dox
new file mode 100755
index 000000000000..b7b0c14b322e
--- /dev/null
+++ b/boards/ccimx95dvk/sm/brd_sm.dox
@@ -0,0 +1,55 @@
+/*
+** ###################################################################
+**
+** Copyright 2023 NXP
+**
+** Redistribution and use in source and binary forms, with or without modification,
+** are permitted provided that the following conditions are met:
+**
+** o Redistributions of source code must retain the above copyright notice, this list
+**   of conditions and the following disclaimer.
+**
+** o Redistributions in binary form must reproduce the above copyright notice, this
+**   list of conditions and the following disclaimer in the documentation and/or
+**   other materials provided with the distribution.
+**
+** o Neither the name of the copyright holder nor the names of its
+**   contributors may be used to endorse or promote products derived from this
+**   software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+** LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+** ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**
+** ###################################################################
+*/
+
+/*!
+ * @addtogroup BRD_SM
+ * @{
+ */
+
+/*!
+
+@defgroup BRD_SM_MX95EVK BOARD_MX95EVK: i.MX95 EVK SM Implementation
+
+@brief Module for the i.MX95 EVK for the SM.
+
+Board Module
+============
+
+This port supports i.MX95 on both the LPDDR4X and LPDDR5 EVKs. See
+the @ref PORT_MX95_EVK section for more information.
+
+*/
+
+/** @} */
+
diff --git a/boards/ccimx95dvk/sm/brd_sm.h b/boards/ccimx95dvk/sm/brd_sm.h
new file mode 100755
index 000000000000..ce758e1e4c64
--- /dev/null
+++ b/boards/ccimx95dvk/sm/brd_sm.h
@@ -0,0 +1,100 @@
+/*
+** ###################################################################
+**
+** Copyright 2023-2024 NXP
+**
+** Redistribution and use in source and binary forms, with or without modification,
+** are permitted provided that the following conditions are met:
+**
+** o Redistributions of source code must retain the above copyright notice, this list
+**   of conditions and the following disclaimer.
+**
+** o Redistributions in binary form must reproduce the above copyright notice, this
+**   list of conditions and the following disclaimer in the documentation and/or
+**   other materials provided with the distribution.
+**
+** o Neither the name of the copyright holder nor the names of its
+**   contributors may be used to endorse or promote products derived from this
+**   software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+** LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+** ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**
+** ###################################################################
+*/
+
+#ifndef BRD_SM_H
+#define BRD_SM_H
+
+/*==========================================================================*/
+/*!
+ * @addtogroup BRD_SM_MX95EVK
+ * @{
+ *
+ * @file
+ * @brief
+ *
+ * Header file containing the API for the SM abstraction of the board.
+ */
+/*==========================================================================*/
+
+/* Includes */
+
+#include "sm.h"
+#include "brd_sm_handlers.h"
+#include "brd_sm_control.h"
+#include "brd_sm_sensor.h"
+#include "brd_sm_voltage.h"
+#include "brd_sm_bbm.h"
+#include "board.h"
+#include "brd_sm_api.h"
+
+/* Defines */
+
+/*! Board name string */
+#define BRD_SM_NAME  "i.MX95 EVK"
+
+/*! Board attributes */
+#define BRD_SM_ATTR  0x0
+
+/*! Perf voltage drop */
+#define BOARD_PERF_VDROP  20000
+
+/*!
+ * @name Board redirection defines
+ * @{
+ */
+#define SM_SYSTEMRESET  BRD_SM_SystemReset       /*!< Reset */
+/** @} */
+
+/* Types */
+
+/* External variables */
+
+/* Functions */
+
+/*!
+ * Reset the system.
+ *
+ * Redirect to just spin.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_SUCCESS
+ */
+int32_t BRD_SM_SystemReset(void);
+
+/** @} */
+
+#endif /* BRD_SM_H */
+
diff --git a/boards/ccimx95dvk/sm/brd_sm_bbm.c b/boards/ccimx95dvk/sm/brd_sm_bbm.c
new file mode 100755
index 000000000000..c2e5cd61dc9f
--- /dev/null
+++ b/boards/ccimx95dvk/sm/brd_sm_bbm.c
@@ -0,0 +1,674 @@
+/*
+** ###################################################################
+**
+** Copyright 2025 NXP
+**
+** Redistribution and use in source and binary forms, with or without modification,
+** are permitted provided that the following conditions are met:
+**
+** o Redistributions of source code must retain the above copyright notice, this list
+**   of conditions and the following disclaimer.
+**
+** o Redistributions in binary form must reproduce the above copyright notice, this
+**   list of conditions and the following disclaimer in the documentation and/or
+**   other materials provided with the distribution.
+**
+** o Neither the name of the copyright holder nor the names of its
+**   contributors may be used to endorse or promote products derived from this
+**   software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+** LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+** ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**
+** ###################################################################
+*/
+
+/*==========================================================================*/
+/* File containing the implementation of the PCA2131 RTC.                   */
+/*==========================================================================*/
+
+/* Note this code is an example. The conversion functions between date and
+   seconds have not been fully tested to match The PCA2131 and calling
+   agents. */
+
+/* Includes */
+
+#include "sm.h"
+#include "brd_sm.h"
+#include "lmm.h"
+
+/* Local defines */
+
+/* Local types */
+
+/* Local variables */
+
+/* Local functions */
+
+static bool days2date(uint32_t days, uint32_t *year, uint32_t *month,
+    uint32_t *day, uint32_t *weekday);
+static void date2days(uint32_t year, uint32_t month, uint32_t day,
+    uint32_t *days);
+
+/*--------------------------------------------------------------------------*/
+/* Write RTC raw data                                                       */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_BbmRtcWrite(uint32_t addr, uint32_t numVal,
+    const uint32_t *val)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Check read size */
+    if (numVal > 24U)
+    {
+        status = SM_ERR_INVALID_PARAMETERS;
+    }
+    else
+    {
+        uint8_t buf[24];
+
+        /* Copy buffer (convert to 8-bit) */
+        for (uint32_t idx = 0U; idx < numVal; idx++)
+        {
+            buf[idx] = U32_U8(val[idx]);
+        }
+
+        /* Write data */
+        if (!PCA2131_RtcWrite(&g_pca2131Dev, U32_U8(addr),
+            U32_U8(numVal), buf))
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Read RTC raw data                                                        */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_BbmRtcRead(uint32_t addr, uint32_t numVal, uint32_t *val)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Check read size */
+    if (numVal > 24U)
+    {
+        status = SM_ERR_INVALID_PARAMETERS;
+    }
+    else
+    {
+        uint8_t buf[24] = { 0 };
+
+        /* Read data */
+        if (PCA2131_RtcRead(&g_pca2131Dev, U32_U8(addr),
+            U32_U8(numVal), buf))
+        {
+            /* Copy buffer (convert to 32-bit) */
+            for (uint32_t idx = 0U; idx < numVal; idx++)
+            {
+                val[idx] = (uint32_t) buf[idx];
+            }
+        }
+        else
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Return RTC name                                                          */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_BbmRtcNameGet(uint32_t rtcId, string *rtcNameAddr,
+    int32_t *len)
+{
+    int32_t status = SM_ERR_SUCCESS;
+    static int32_t s_maxLen = 0;
+
+    static string const s_name[BRD_SM_NUM_RTC] =
+    {
+        "pca2131"
+    };
+
+    /* Get max string width */
+    DEV_SM_MaxStringGet(len, &s_maxLen, s_name, BRD_SM_NUM_RTC);
+
+    if (rtcId < DEV_SM_NUM_RTC)
+    {
+        status = DEV_SM_BbmRtcNameGet(rtcId, rtcNameAddr, len);
+    }
+    else
+    {
+        /* Return pointer to name */
+        *rtcNameAddr = s_name[rtcId - DEV_SM_NUM_RTC];
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Return RTC info                                                          */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_BbmRtcDescribe(uint32_t rtcId, uint32_t *secWidth,
+    uint32_t *tickWidth, uint32_t *ticksPerSec)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    if (rtcId < DEV_SM_NUM_RTC)
+    {
+        status = DEV_SM_BbmRtcDescribe(rtcId, secWidth, tickWidth,
+            ticksPerSec);
+    }
+    else
+    {
+        /* Return RTC info */
+        *secWidth = 32U;
+        *tickWidth = 39U;
+        *ticksPerSec = 100U;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Set RTC time                                                             */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_BbmRtcTimeSet(uint32_t rtcId, uint64_t val, bool ticks)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    if (rtcId < DEV_SM_NUM_RTC)
+    {
+        status = DEV_SM_BbmRtcTimeSet(rtcId, val, ticks);
+    }
+    else
+    {
+        uint32_t year, month, day, hour, min, sec, hun, weekday;
+        uint32_t days, hours, mins, secs;
+
+        /* Convert to hundredths of seconds */
+        if (ticks)
+        {
+            uint64_t sec64, hun64;
+
+            sec64 = val / 100U;
+            hun64 = val - (sec64 * 100U);
+
+            secs = U64_U32(sec64);
+            hun = U64_U32(hun64);
+        }
+        else
+        {
+            hun = 0U;
+            secs = U64_U32(val);
+        }
+
+        /* Calculate totals */
+        mins = secs / 60U;
+        hours = secs / 3600U;
+        days = secs / 86400U;
+
+        /* Calculate time */
+        sec = secs % 60U;
+        min = mins % 60U;
+        hour = hours % 24U;
+
+        /* Convert to date */
+        if (days2date(days, &year, &month, &day, &weekday)
+            && (year <= 2069U))
+        {
+            /* Convert year */
+            year %= 100U;
+
+            /* Write RTC */
+            if (!PCA2131_RtcSet(&g_pca2131Dev, year, month, day, hour,
+                min, sec, hun, weekday))
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+        }
+        else
+        {
+            status = SM_ERR_INVALID_PARAMETERS;
+        }
+    }
+
+    if (status == SM_ERR_SUCCESS)
+    {
+        /* Enable battery */
+        (void) PCA2131_PowerModeSet(&g_pca2131Dev, 0U);
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Get RTC time                                                             */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_BbmRtcTimeGet(uint32_t rtcId, uint64_t *val, bool ticks)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    if (rtcId < DEV_SM_NUM_RTC)
+    {
+        status = DEV_SM_BbmRtcTimeGet(rtcId, val, ticks);
+    }
+    else
+    {
+        uint32_t year, month, day, hour, min, sec, hun, weekday;
+
+        /* Read RTC */
+        if (PCA2131_RtcGet(&g_pca2131Dev, &year, &month, &day, &hour, &min,
+            &sec, &hun, &weekday))
+        {
+            uint32_t days, secs;
+
+            /* Convert year */
+            if (year >= 70U)
+            {
+                year = year + 1900U;
+            }
+            else
+            {
+                year = year + 2000U;
+            }
+
+            /* Convert to days */
+            date2days(year, month, day, &days);
+
+            /* Calculate seconds */
+            secs = sec + (min * 60U) + (hour * 3600U);
+            secs += (days * 86400U);
+
+            /* Check time format */
+            if (ticks)
+            {
+                *val = (((uint64_t) secs) * 100U) + hun;
+            }
+            else
+            {
+                *val = ((uint64_t) secs);
+            }
+        }
+        else
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Get BBM RTC state                                                        */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_BbmRtcStateGet(uint32_t rtcId, uint32_t *state)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    if (rtcId < DEV_SM_NUM_RTC)
+    {
+        status = DEV_SM_BbmRtcStateGet(rtcId, state);
+    }
+    else
+    {
+        bool st;
+
+        /* Default state */
+        *state = 0U;
+
+        /* Enable battery */
+        (void) PCA2131_PowerModeSet(&g_pca2131Dev, 0U);
+
+        /* Get battery state */
+        if (PCA2131_TimeStatusGet(&g_pca2131Dev, &st))
+        {
+            if (st)
+            {
+                *state |= LMM_BBM_STATE_RESET;
+            }
+        }
+        else
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+
+        /* Get battery state */
+        if (PCA2131_BattStatusGet(&g_pca2131Dev, &st))
+        {
+            if (st)
+            {
+                *state |= LMM_BBM_STATE_BATT_LOW;
+            }
+        }
+        else
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Set RTC alarm                                                            */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_BbmRtcAlarmSet(uint32_t rtcId, bool enable, uint64_t val)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    if (rtcId < DEV_SM_NUM_RTC)
+    {
+        status = DEV_SM_BbmRtcAlarmSet(rtcId, enable, val);
+    }
+    else
+    {
+        /* Enable? */
+        if (enable)
+        {
+            uint32_t year, month, day, hour, min, sec, weekday;
+            uint32_t days, hours, mins, secs;
+
+            /* Convert to seconds */
+            secs = U64_U32(val);
+
+            /* Calculate totals */
+            mins = secs / 60U;
+            hours = secs / 3600U;
+            days = secs / 86400U;
+
+            /* Calculate time */
+            sec = secs % 60U;
+            min = mins % 60U;
+            hour = hours % 24U;
+
+            /* Convert to date */
+            if (days2date(days, &year, &month, &day, &weekday)
+                && (year <= 2069U))
+            {
+                /* Convert year */
+                year %= 100U;
+
+                /* Write to RTC */
+                if (PCA2131_AlarmSet(&g_pca2131Dev, day, hour, min, sec,
+                    weekday))
+                {
+                    /* Enable interrupt */
+                    if (PCA2131_IntEnable(&g_pca2131Dev, true))
+                    {
+                        /* Enable bus expander interrupt */
+                        status = BRD_SM_BusExpMaskSet(0U, BIT8(6));
+                    }
+                    else
+                    {
+                        status = SM_ERR_HARDWARE_ERROR;
+                    }
+                }
+            }
+            else
+            {
+                status = SM_ERR_INVALID_PARAMETERS;
+            }
+
+            /* Track if enabled for PCA2131 use */
+            if (status == SM_ERR_SUCCESS)
+            {
+                g_pca2131Used = true;
+            }
+        }
+        else
+        {
+            /* Disable interrupt */
+            if (PCA2131_IntEnable(&g_pca2131Dev, false))
+            {
+                /* Disable bus expander interrupt */
+                status = BRD_SM_BusExpMaskSet(BIT8(6), BIT8(6));
+            }
+            else
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+        }
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* PCA2131 interrupt handler                                                */
+/*--------------------------------------------------------------------------*/
+void BRD_SM_BbmHandler(void)
+{
+    /* Handle alarm */
+    LMM_BbmRtcAlarmEvent(BRD_SM_RTC_PCA2131);
+
+    /* Clear status flags */
+    (void) PCA2131_IntClear(&g_pca2131Dev);
+}
+
+/*==========================================================================*/
+
+/*--------------------------------------------------------------------------*/
+/* Convert days since 1-1-1970 to date/time                                 */
+/*--------------------------------------------------------------------------*/
+static bool days2date(uint32_t days, uint32_t *year, uint32_t *month,
+    uint32_t *day, uint32_t *weekday)
+{
+    bool rc = true;
+    uint32_t newDays = 0U;
+    uint32_t era = 0U;
+    uint32_t doe = 0U;
+    uint32_t yoe = 0U;
+    uint32_t doy = 0U;
+    uint32_t moy = 0U;
+
+    /* Check days value doesn't wrap */
+    if (days <= (UINT32_MAX - 719468U))
+    {
+        /* Adjust to 1-1-1970) */
+        newDays = days + 719468U;
+    }
+    else
+    {
+        /* Set the return code incase value wraps */
+        rc = false;
+    }
+
+    if (rc)
+    {
+        /* Calculate the era */
+        era = newDays / 146097U;
+
+        /* Check the expression doesn't wrap due to negative value */
+        if (newDays >= (era * 146097U))
+        {
+            /* Calculate the day in the era */
+            doe = newDays - (era * 146097U);
+        }
+        else
+        {
+            /* Set the return code if the expression value wraps */
+            rc = false;
+        }
+    }
+
+    if (rc)
+    {
+        /* Check the expression doesn't wrap due to negative value */
+        if (doe >= (doe / 1460U))
+        {
+            /* Calculate the year of era */
+            yoe = (doe - (doe / 1460U) + (doe / 36524U));
+
+            /* Check the expression doesn't wrap due to negative value */
+            if (yoe >= (doe / 146096U))
+            {
+                yoe -= (doe / 146096U);
+                yoe /= 365U;
+            }
+            else
+            {
+                /* Set the return code if the expression value wraps */
+                rc = false;
+            }
+        }
+        else
+        {
+            /* Set the return code if the expression value wraps */
+            rc = false;
+        }
+    }
+
+    if (rc)
+    {
+        /* Check the expression doesn't wrap due to negative value */
+        if (yoe <= (UINT32_MAX - (era * 400U)))
+        {
+            /* Calculate year */
+            *year = yoe + (era * 400U);
+        }
+        else
+        {
+            /* Set the return code if the expression value wraps */
+            rc = false;
+        }
+    }
+
+    if (rc)
+    {
+        /* Check the expression doesn't wrap due to negative value */
+        if (doe >= (365U * yoe))
+        {
+            /* Calculate day of the year */
+            doy = doe - (365U * yoe);
+
+            /* Check the expression doesn't wrap due to negative  value */
+            if (doy >= (yoe / 4U))
+            {
+                doy -= (yoe / 4U);
+                doy += (yoe / 100U);
+            }
+            else
+            {
+                /* Set the return code if the expression value wraps */
+                rc = false;
+            }
+        }
+        else
+        {
+            /* Set the return code if the expression value wraps */
+            rc = false;
+        }
+    }
+
+    if (rc)
+    {
+        /* Check the expression doesn't wrap due to negative value */
+        if (doy <= (UINT32_MAX / 5U))
+        {
+            /* Calculate month of year */
+            moy = ((5U * doy) + 2U) / 153U;
+        }
+        else
+        {
+            /* Set the return code if the expression value wraps */
+            rc = false;
+        }
+    }
+
+
+    if (rc)
+    {
+        /* Check the expression doesn't wrap due to negative value */
+        if (moy <= ((UINT32_MAX - 2U) / 153U))
+        {
+            /* Calculate day */
+            *day = (((153U * moy) + 2U) / 5U) - 1U;
+            if (doy >= *day)
+            {
+                *day = doy - *day;
+            }
+            else
+            {
+                /* Set the return code if the expression value wraps */
+                rc = false;
+            }
+        }
+        else
+        {
+            /* Set the return code if the expression value wraps */
+            rc = false;
+        }
+    }
+
+    if (rc)
+    {
+        /* Calculate month */
+        *month= (moy < 10U) ? (moy + 3U) : (moy - 9U);
+
+        /* Calculate day of the week */
+        *weekday = (days + 4U) % 7U;
+
+        /* Adjust year */
+        *year += (*month <= 2U) ? 1U : 0U;
+    }
+
+    /* Return code */
+    return rc;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Convert date/time to days since 1-1-1970                                 */
+/*--------------------------------------------------------------------------*/
+static void date2days(uint32_t year, uint32_t month, uint32_t day,
+    uint32_t *days)
+{
+    uint32_t newYear;
+    uint32_t era;
+    uint32_t doe;
+    uint32_t yoe;
+    uint32_t doy;
+    uint32_t moy;
+
+    /* Adjust year */
+    newYear = year - ((month <= 2U) ? 1U : 0U);
+
+    /* Calculate era */
+    era = newYear / 400U;
+
+    /* Calculate the year of era */
+    yoe = newYear - (era * 400U);
+
+    /* Calculate month of year */
+    moy = (month > 2U) ? (month - 3U) : (month + 9U);
+
+    /* Calculate day of the year */
+    doy = (((153U * moy) + 2U) / 5U) + (day - 1U);
+
+    /* Calculate the day in the era */
+    doe = (yoe * 365U) + (yoe / 4U) - (yoe / 100U) + doy;
+
+    /* Calculate days */
+    *days = (era * 146097U) + doe - 719468U;
+}
+
diff --git a/boards/ccimx95dvk/sm/brd_sm_bbm.h b/boards/ccimx95dvk/sm/brd_sm_bbm.h
new file mode 100755
index 000000000000..a96a8e1cc901
--- /dev/null
+++ b/boards/ccimx95dvk/sm/brd_sm_bbm.h
@@ -0,0 +1,242 @@
+/*
+** ###################################################################
+**
+** Copyright 2024 NXP
+**
+** Redistribution and use in source and binary forms, with or without modification,
+** are permitted provided that the following conditions are met:
+**
+** o Redistributions of source code must retain the above copyright notice, this list
+**   of conditions and the following disclaimer.
+**
+** o Redistributions in binary form must reproduce the above copyright notice, this
+**   list of conditions and the following disclaimer in the documentation and/or
+**   other materials provided with the distribution.
+**
+** o Neither the name of the copyright holder nor the names of its
+**   contributors may be used to endorse or promote products derived from this
+**   software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+** LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+** ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**
+** ###################################################################
+*/
+
+/*==========================================================================*/
+/*!
+ * @addtogroup BRD_SM_MX95EVK
+ * @{
+ *
+ * @file
+ * @brief
+ *
+ * Header file containing the SM API for the board PCA2131.
+ */
+/*==========================================================================*/
+
+#ifndef BRD_SM_BBM_H
+#define BRD_SM_BBM_H
+
+/* Includes */
+
+#include "sm.h"
+#include "dev_sm.h"
+#include "fsl_pca2131.h"
+
+/* Defines */
+
+/*!
+ * @name Board redirection defines
+ * @{
+ */
+#define SM_BBMRTCNAMEGET       BRD_SM_BbmRtcNameGet       /*!< RTC name */
+#define SM_BBMRTCDESCRIBE      BRD_SM_BbmRtcDescribe      /*!< RTC describe */
+#define SM_BBMRTCTIMESET       BRD_SM_BbmRtcTimeSet       /*!< RTC time set */
+#define SM_BBMRTCTIMEGET       BRD_SM_BbmRtcTimeGet       /*!< RTC time get */
+#define SM_BBMRTCSTATEGET      BRD_SM_BbmRtcStateGet      /*!< RTC state get */
+#define SM_BBMRTCALARMSET      BRD_SM_BbmRtcAlarmSet      /*!< RTC alarm set */
+/** @} */
+
+/*! Number of board RTC */
+#define BRD_SM_NUM_RTC  1UL
+
+/*! Total number of RTC */
+#define SM_NUM_RTC  (DEV_SM_NUM_RTC + BRD_SM_NUM_RTC)
+
+/*!
+ * @name BRD_SM bbm domain indexes
+ */
+/** @{ */
+#define BRD_SM_RTC_PCA2131  (BRD_SM_NUM_RTC + 0U)   /*!< PCA2131 RTC */
+/** @} */
+
+/* Types */
+
+/* Functions */
+
+/*!
+ * @name Board sensor functions
+ * @{
+ */
+
+/*!
+ * Read raw byte data from the RTC.
+ *
+ * @param[in]     addr    I2C address to read
+ * @param[in]     numVal  Number of bytes to read
+ * @param[out]    val     Return pointer for data
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_INVALID_PARAMETERS: if \a numVal is invalid.
+ * - ::SM_ERR_HARDWARE_ERROR: if I2C transfer fails.
+ */
+int32_t BRD_SM_BbmRtcWrite(uint32_t addr, uint32_t numVal,
+    const uint32_t *val);
+
+/*!
+ * Write raw byte data to the RTC.
+ *
+ * @param[in]     addr    I2C address to write
+ * @param[in]     numVal  Number of bytes to write
+ * @param[in]     val     Pointer to data
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_INVALID_PARAMETERS: if \a numVal is invalid.
+ * - ::SM_ERR_HARDWARE_ERROR: if I2C transfer fails.
+ */
+int32_t BRD_SM_BbmRtcRead(uint32_t addr, uint32_t numVal, uint32_t *val);
+
+/*!
+ * Get a board RTC name.
+ *
+ * @param[in]     rtcId        RTC name to get
+ * @param[out]    rtcNameAddr  Return pointer to name
+ * @param[out]    len          Return max length of all RTC names
+ *
+ * This function allows the caller to get the name of an RTC.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a rtcId is invalid.
+ */
+int32_t BRD_SM_BbmRtcNameGet(uint32_t rtcId, string *rtcNameAddr,
+    int32_t *len);
+
+/*!
+ * Get a board RTC description.
+ *
+ * @param[in]     rtcId        RTC description to get
+ * @param[out]    secWidth     Return pointer to seconds width
+ * @param[out]    tickWidth    Return pointer to tick width
+ * @param[out]    ticksPerSec  Return pointer to ticks per second
+ *
+ * This function allows the caller to get the description of an RTC.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a rtcId is invalid.
+ */
+int32_t BRD_SM_BbmRtcDescribe(uint32_t rtcId, uint32_t *secWidth,
+    uint32_t *tickWidth, uint32_t *ticksPerSec);
+
+/*!
+ * Set a board RTC time.
+ *
+ * @param[in]     rtcId    Identifier of the RTC
+ * @param[in]     val      Time in seconds/ticks to write to the RTC
+ * @param[in]     ticks    true = ticks, false = seconds
+ *
+ * This function allows a caller to set the RTC time. Time can be set in units
+ * of ticks or seconds.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_SUCCESS: if the RTC time was successfully set.
+ * - ::SM_ERR_NOT_FOUND: if \a rtcId pertains to a non-existent RTC.
+ * - ::SM_ERR_INVALID_PARAMETERS: if the time is not valid (beyond the
+ *   range of the RTC).
+ */
+int32_t BRD_SM_BbmRtcTimeSet(uint32_t rtcId, uint64_t val, bool ticks);
+
+/*!
+ * Get a board RTC time.
+ *
+ * @param[in]     rtcId    Identifier of the RTC
+ * @param[out]    val      Time in seconds/ticks read from the RTC
+ * @param[in]     ticks    true = ticks, false = seconds
+ *
+ * This function allows a caller to read the RTC time. Time can be read in
+ * units of ticks or seconds.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_SUCCESS: if the RTC time was successfully read.
+ * - ::SM_ERR_NOT_FOUND: if \a rtcId pertains to a non-existent RTC.
+ */
+int32_t BRD_SM_BbmRtcTimeGet(uint32_t rtcId, uint64_t *val, bool ticks);
+
+/*!
+ * Get a board RTC state.
+ *
+ * @param[in]     rtcId    Identifier of the RTC
+ * @param[out]    state    Bit mask of state flags
+ *
+ * This function allows a caller to read the RTC state.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_SUCCESS: if the RTC state was successfully read.
+ * - ::SM_ERR_NOT_FOUND: if \a rtcId pertains to a non-existent RTC.
+ */
+int32_t BRD_SM_BbmRtcStateGet(uint32_t rtcId, uint32_t *state);
+
+/*!
+ * Set a board RTC alarm.
+ *
+ * @param[in]     rtcId    Identifier of the RTC
+ * @param[in]     enable   Enable flag (1=enabled, 0=disabled)
+ * @param[in]     val      Alarm time in seconds to write to the RTC
+ *
+ * This function allows a caller to enable/disable and set the time for the RTC
+ * alarm. The alarm can be set in seconds only.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_SUCCESS: if the alarm was successfully set.
+ * - ::SM_ERR_NOT_FOUND: if \a rtcId pertains to a non-existent RTC.
+ * - ::SM_ERR_INVALID_PARAMETERS: if the time is not valid (beyond the
+ *   range of the RTC alarm).
+ */
+int32_t BRD_SM_BbmRtcAlarmSet(uint32_t rtcId, bool enable, uint64_t val);
+
+/*!
+ * Handle PCA2131 interrupt.
+ */
+void BRD_SM_BbmHandler(void);
+
+/** @} */
+
+#endif /* BRD_SM_BBM_H */
+
+/** @} */
+
diff --git a/boards/ccimx95dvk/sm/brd_sm_control.c b/boards/ccimx95dvk/sm/brd_sm_control.c
new file mode 100755
index 000000000000..5b36c66c593c
--- /dev/null
+++ b/boards/ccimx95dvk/sm/brd_sm_control.c
@@ -0,0 +1,317 @@
+/*
+** ###################################################################
+**
+**     Copyright 2023-2024 NXP
+**
+**     Redistribution and use in source and binary forms, with or without modification,
+**     are permitted provided that the following conditions are met:
+**
+**     o Redistributions of source code must retain the above copyright notice, this list
+**       of conditions and the following disclaimer.
+**
+**     o Redistributions in binary form must reproduce the above copyright notice, this
+**       list of conditions and the following disclaimer in the documentation and/or
+**       other materials provided with the distribution.
+**
+**     o Neither the name of the copyright holder nor the names of its
+**       contributors may be used to endorse or promote products derived from this
+**       software without specific prior written permission.
+**
+**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**
+** ###################################################################
+*/
+
+/*==========================================================================*/
+/* File containing the implementation of the board controls.                */
+/*==========================================================================*/
+
+/* Includes */
+
+#include "sm.h"
+#include "brd_sm.h"
+#include "lmm.h"
+
+/* Local defines */
+
+/* PCAL6408A input signals */
+#define PCAL6408A_INPUT_SD3_WAKE     0U
+#define PCAL6408A_INPUT_PCIE1_WAKE   4U
+#define PCAL6408A_INPUT_BT_WAKE      5U
+#define PCAL6408A_INPUT_PCIE2_WAKE   6U
+#define PCAL6408A_INPUT_BUTTON       7U
+
+/* Local types */
+
+/* Local variables */
+
+/*--------------------------------------------------------------------------*/
+/* Set a control value                                                      */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_ControlSet(uint32_t ctrlId, uint32_t numVal,
+    const uint32_t *val)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Check to see if ctrlId is within bounds*/
+    if (ctrlId < SM_NUM_CTRL)
+    {
+        /* Check if device or board */
+        if (ctrlId < DEV_SM_NUM_CTRL)
+        {
+            status = DEV_SM_ControlSet(ctrlId, numVal, val);
+        }
+        else if (ctrlId == BRD_SM_CTRL_PCA2131)
+        {
+            status = SM_ERR_NOT_SUPPORTED;
+        }
+        else if (ctrlId == BRD_SM_CTRL_TEST)
+        {
+            /* Test response to an reported SM error */
+            SM_Error(SM_ERR_GENERIC_ERROR);
+        }
+        else
+        {
+            status = SM_ERR_NOT_SUPPORTED;
+        }
+    }
+    else
+    {
+        status = SM_ERR_NOT_FOUND;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Get a control value                                                      */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_ControlGet(uint32_t ctrlId, uint32_t *numRtn, uint32_t *rtn)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Check to see if ctrlId is within bounds*/
+    if (ctrlId < SM_NUM_CTRL)
+    {
+        /* Check if device or board */
+        if (ctrlId < DEV_SM_NUM_CTRL)
+        {
+            status = DEV_SM_ControlGet(ctrlId, numRtn, rtn);
+        }
+        else if ((ctrlId == BRD_SM_CTRL_PCA2131)
+            || (ctrlId == BRD_SM_CTRL_TEST))
+        {
+            *numRtn = 0U;
+            status = SM_ERR_NOT_SUPPORTED;
+        }
+        else
+        {
+            uint8_t data;
+
+            /* Read expander data input */
+            if (PCAL6408A_InputGet(&g_pcal6408aDev, &data))
+            {
+                uint32_t shift = ctrlId - DEV_SM_NUM_CTRL;
+
+                /* Adjust bit position */
+                if (shift > 0U)
+                {
+                    shift += 3U;
+                }
+
+                *numRtn = 1U;
+                rtn[0] = (((uint32_t) data) >> shift) & 0x1UL;
+            }
+            else
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+        }
+    }
+    else
+    {
+        *numRtn = 0U;
+        status = SM_ERR_NOT_FOUND;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Set an extended control value                                            */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_ControlExtSet(uint32_t ctrlId, uint32_t addr,
+    uint32_t numVal, const uint32_t *val)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Check to see if ctrlId is within bounds*/
+    if (ctrlId < SM_NUM_CTRL)
+    {
+        /* Check if device or board */
+        if (ctrlId < DEV_SM_NUM_CTRL)
+        {
+            status = DEV_SM_ControlExtSet(ctrlId, addr, numVal, val);
+        }
+        else if (ctrlId == BRD_SM_CTRL_PCA2131)
+        {
+            status = BRD_SM_BbmRtcWrite(addr, numVal, val);
+        }
+        else
+        {
+            status = SM_ERR_NOT_SUPPORTED;
+        }
+    }
+    else
+    {
+        status = SM_ERR_NOT_FOUND;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Get an extended control value                                            */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_ControlExtGet(uint32_t ctrlId, uint32_t addr,
+    uint32_t numRtn, uint32_t *rtn)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Check to see if ctrlId is within bounds*/
+    if (ctrlId < SM_NUM_CTRL)
+    {
+        /* Check if device or board */
+        if (ctrlId < DEV_SM_NUM_CTRL)
+        {
+            status = DEV_SM_ControlExtGet(ctrlId, addr, numRtn, rtn);
+        }
+        else if (ctrlId == BRD_SM_CTRL_PCA2131)
+        {
+            status = BRD_SM_BbmRtcRead(addr, numRtn, rtn);
+        }
+        else
+        {
+            status = SM_ERR_NOT_SUPPORTED;
+        }
+    }
+    else
+    {
+        status = SM_ERR_NOT_FOUND;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Configure notification flags                                             */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_ControlFlagsSet(uint32_t ctrlId, uint32_t flags)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Check if device or board */
+    if (ctrlId < DEV_SM_NUM_CTRL)
+    {
+        status = DEV_SM_ControlFlagsSet(ctrlId, flags);
+    }
+    else
+    {
+        uint8_t mask;
+        uint32_t val;
+        uint32_t enb = (flags != 0U) ? 0U : 1U;
+
+        switch (ctrlId)
+        {
+            case BRD_SM_CTRL_SD3_WAKE:
+                mask = BIT8(PCAL6408A_INPUT_SD3_WAKE);
+                val = (enb & 0x1U) << PCAL6408A_INPUT_SD3_WAKE;
+                break;
+            case BRD_SM_CTRL_PCIE1_WAKE:
+                mask = BIT8(PCAL6408A_INPUT_PCIE1_WAKE);
+                val = (enb & 0x1U) << PCAL6408A_INPUT_PCIE1_WAKE;
+                break;
+            case BRD_SM_CTRL_BT_WAKE:
+                mask = BIT8(PCAL6408A_INPUT_BT_WAKE);
+                val = (enb & 0x1U) << PCAL6408A_INPUT_BT_WAKE;
+                break;
+            case BRD_SM_CTRL_PCIE2_WAKE:
+                mask = BIT8(PCAL6408A_INPUT_PCIE2_WAKE);
+                val = (enb & 0x1U) << PCAL6408A_INPUT_PCIE2_WAKE;
+                break;
+            case BRD_SM_CTRL_BUTTON:
+                mask = BIT8(PCAL6408A_INPUT_BUTTON);
+                val = (enb & 0x1U) << PCAL6408A_INPUT_BUTTON;
+                break;
+            default:
+                status = SM_ERR_NOT_FOUND;
+                break;
+        }
+
+        if (status == SM_ERR_SUCCESS)
+        {
+            status = BRD_SM_BusExpMaskSet((uint8_t) val, mask);
+        }
+    }
+
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Control handler                                                          */
+/*--------------------------------------------------------------------------*/
+void BRD_SM_ControlHandler(uint8_t status, uint8_t val)
+{
+    uint32_t data = (uint32_t) val;
+
+    /* Handle SD3 wake */
+    if ((status & BIT8(PCAL6408A_INPUT_SD3_WAKE)) != 0U)
+    {
+        LMM_MiscControlEvent(BRD_SM_CTRL_SD3_WAKE,
+            ((data >> PCAL6408A_INPUT_SD3_WAKE) & 0x1U) + 1U);
+    }
+
+    /* Handle PCIe1 wake */
+    if ((status & BIT8(PCAL6408A_INPUT_PCIE1_WAKE)) != 0U)
+    {
+        LMM_MiscControlEvent(BRD_SM_CTRL_PCIE1_WAKE,
+            ((data >> PCAL6408A_INPUT_PCIE1_WAKE) & 0x1U) + 1U);
+    }
+
+    /* Handle BT wake */
+    if ((status & BIT8(PCAL6408A_INPUT_BT_WAKE)) != 0U)
+    {
+        LMM_MiscControlEvent(BRD_SM_CTRL_BT_WAKE,
+            ((data >> PCAL6408A_INPUT_BT_WAKE) & 0x1U) + 1U);
+    }
+
+    /* Handle PCIe2 wake */
+    if (((status & BIT8(PCAL6408A_INPUT_PCIE2_WAKE)) != 0U)
+        && !g_pca2131Used)
+    {
+        LMM_MiscControlEvent(BRD_SM_CTRL_PCIE2_WAKE,
+            ((data >> PCAL6408A_INPUT_PCIE2_WAKE) & 0x1U) + 1U);
+    }
+
+    /* Handle button */
+    if ((status & BIT8(PCAL6408A_INPUT_BUTTON)) != 0U)
+    {
+        LMM_MiscControlEvent(BRD_SM_CTRL_BUTTON,
+            ((data >> PCAL6408A_INPUT_BUTTON) & 0x1U) + 1U);
+    }
+}
+
diff --git a/boards/ccimx95dvk/sm/brd_sm_control.h b/boards/ccimx95dvk/sm/brd_sm_control.h
new file mode 100755
index 000000000000..bf893782e1d7
--- /dev/null
+++ b/boards/ccimx95dvk/sm/brd_sm_control.h
@@ -0,0 +1,202 @@
+/*
+** ###################################################################
+**
+**     Copyright 2023-2024 NXP
+**
+**     Redistribution and use in source and binary forms, with or without modification,
+**     are permitted provided that the following conditions are met:
+**
+**     o Redistributions of source code must retain the above copyright notice, this list
+**       of conditions and the following disclaimer.
+**
+**     o Redistributions in binary form must reproduce the above copyright notice, this
+**       list of conditions and the following disclaimer in the documentation and/or
+**       other materials provided with the distribution.
+**
+**     o Neither the name of the copyright holder nor the names of its
+**       contributors may be used to endorse or promote products derived from this
+**       software without specific prior written permission.
+**
+**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**
+** ###################################################################
+*/
+
+/*==========================================================================*/
+/*!
+ * @addtogroup BRD_SM_MX95EVK
+ * @{
+ *
+ * @file
+ * @brief
+ *
+ * Header file containing the SM API for the board controls.
+ */
+/*==========================================================================*/
+
+#ifndef BRD_SM_CONTROL_H
+#define BRD_SM_CONTROL_H
+
+/* Includes */
+
+#include "sm.h"
+#include "dev_sm.h"
+
+/* Defines */
+
+/*!
+ * @name Board redirection defines
+ * @{
+ */
+#define SM_CONTROLSET          BRD_SM_ControlSet          /*!< Control set */
+#define SM_CONTROLGET          BRD_SM_ControlGet          /*!< Control get */
+#define SM_CONTROLEXTSET       BRD_SM_ControlExtSet       /*!< Extended control set */
+#define SM_CONTROLEXTGET       BRD_SM_ControlExtGet       /*!< Extended control get */
+#define SM_CONTROLFLAGSSET     BRD_SM_ControlFlagsSet     /*!< Control flags */
+/** @} */
+
+/*! Number of board controls */
+#define BRD_SM_NUM_CTRL  7UL
+
+/*! Total number of controls */
+#define SM_NUM_CTRL  (DEV_SM_NUM_CTRL + BRD_SM_NUM_CTRL)
+
+/*!
+ * @name BRD_SM control domain indexes
+ */
+/** @{ */
+#define BRD_SM_CTRL_SD3_WAKE    (DEV_SM_NUM_CTRL + 0U)  /*!< PCAL6408A-0 */
+#define BRD_SM_CTRL_PCIE1_WAKE  (DEV_SM_NUM_CTRL + 1U)  /*!< PCAL6408A-4 */
+#define BRD_SM_CTRL_BT_WAKE     (DEV_SM_NUM_CTRL + 2U)  /*!< PCAL6408A-5 */
+#define BRD_SM_CTRL_PCIE2_WAKE  (DEV_SM_NUM_CTRL + 3U)  /*!< PCAL6408A-6 */
+#define BRD_SM_CTRL_BUTTON      (DEV_SM_NUM_CTRL + 4U)  /*!< PCAL6408A-7 */
+#define BRD_SM_CTRL_TEST        (DEV_SM_NUM_CTRL + 5U)  /*!< Test */
+#define BRD_SM_CTRL_PCA2131     (DEV_SM_NUM_CTRL + 6U)  /*!< PCA2131 raw access */
+/** @} */
+
+/* Types */
+
+/* Functions */
+
+/*!
+ * @name Board control functions
+ * @{
+ */
+
+/*!
+ * Set a board control value.
+ *
+ * @param[in]     ctrlId   Index of control to write
+ * @param[in]     numVal   Number of array elements
+ * @param[in]     val      Pointer to array of values to set
+ *
+ * This function allows a caller to write an array of values for
+ * a control.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if ctrlId is not valid.
+ */
+int32_t BRD_SM_ControlSet(uint32_t ctrlId, uint32_t numVal,
+    const uint32_t *val);
+
+/*!
+ * Get a board control value.
+ *
+ * @param[in]     ctrlId   Index of control to read
+ * @param[out]    numRtn   Return pointer to number of array elements
+ * @param[out]    rtn      Pointer to array to store return
+ *
+ * This function allows a caller to read an array of values for
+ * a control.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if ctrlId is not valid.
+ */
+int32_t BRD_SM_ControlGet(uint32_t ctrlId, uint32_t *numRtn, uint32_t *rtn);
+
+/*!
+ * Set an extended board control value.
+ *
+ * @param[in]     ctrlId   Index of control to write
+ * @param[in]     addr     Address of write
+ * @param[in]     numVal   Number of array elements
+ * @param[in]     val      Pointer to array of values to set
+ *
+ * This function allows a caller to write an array of values for
+ * a control. Extra parameters allow this write to be more complex
+ * such as to an I2C.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if ctrlId is not valid.
+ * - ::SM_ERR_INVALID_PARAMETERS: if addr or numVal are not valid.
+ */
+int32_t BRD_SM_ControlExtSet(uint32_t ctrlId, uint32_t addr,
+    uint32_t numVal, const uint32_t *val);
+
+/*!
+ * Get an extended board control value.
+ *
+ * @param[in]     ctrlId   Index of control to read
+ * @param[in]     addr     Address of read
+ * @param[in]     numRtn   Number of array elements
+ * @param[out]    rtn      Pointer to array to store return
+ *
+ * This function allows a caller to read an array of values for
+ * a control. Extra parameters allow this read to be more complex
+ * such as from an I2C.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if ctrlId is not valid.
+ * - ::SM_ERR_INVALID_PARAMETERS: if addr or numRtn are not valid.
+ */
+int32_t BRD_SM_ControlExtGet(uint32_t ctrlId, uint32_t addr,
+    uint32_t numRtn, uint32_t *rtn);
+
+/*!
+ * Configure notification flags for a control.
+ *
+ * @param[in]     ctrlId   Index of control to take action
+ * @param[in]     flags    Action to take
+ *
+ * This function allows a caller to configure the notification flags.
+ * These often enable/disable hardware interrupts.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if ctrlId is not valid.
+ */
+int32_t BRD_SM_ControlFlagsSet(uint32_t ctrlId, uint32_t flags);
+
+/*!
+ * Control handler.
+ *
+ * @param[in]     status   Interrupt status
+ * @param[in]     val      Signal state
+ */
+void BRD_SM_ControlHandler(uint8_t status, uint8_t val);
+
+/** @} */
+
+#endif /* BRD_SM_CONTROL_H */
+
+/** @} */
+
diff --git a/boards/ccimx95dvk/sm/brd_sm_handlers.c b/boards/ccimx95dvk/sm/brd_sm_handlers.c
new file mode 100755
index 000000000000..a96f6ce0e2f4
--- /dev/null
+++ b/boards/ccimx95dvk/sm/brd_sm_handlers.c
@@ -0,0 +1,372 @@
+/*
+** ###################################################################
+**
+** Copyright 2023-2025 NXP
+**
+** Redistribution and use in source and binary forms, with or without modification,
+** are permitted provided that the following conditions are met:
+**
+** o Redistributions of source code must retain the above copyright notice, this list
+**   of conditions and the following disclaimer.
+**
+** o Redistributions in binary form must reproduce the above copyright notice, this
+**   list of conditions and the following disclaimer in the documentation and/or
+**   other materials provided with the distribution.
+**
+** o Neither the name of the copyright holder nor the names of its
+**   contributors may be used to endorse or promote products derived from this
+**   software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+** LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+** ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**
+** ###################################################################
+*/
+
+/*==========================================================================*/
+/* File containing the implementation of the handlers for the board.        */
+/*==========================================================================*/
+
+/* Includes */
+
+#include "sm.h"
+#include "brd_sm.h"
+#include "dev_sm.h"
+#include "fsl_lpi2c.h"
+#include "fsl_rgpio.h"
+
+/* Local defines */
+
+/* I2C device addresses */
+#define BOARD_PF09_DEV_ADDR         0x08U
+#define BOARD_PCAL6408A_DEV_ADDR    0x20U
+#define BOARD_PF5301_DEV_ADDR       0x2AU
+#define BOARD_PF5302_DEV_ADDR       0x29U
+#define BOARD_PCA2131_DEV_ADDR      0x53U
+
+#define PCAL6408A_INPUT_PF53_ARM_PG  1U
+#define PCAL6408A_INPUT_PF53_SOC_PG  2U
+#define PCAL6408A_INPUT_PF09_INT     3U
+#define PCAL6408A_INPUT_PCA2131_INT  6U
+
+/* Local types */
+
+/* Local variables */
+
+/* Global variables */
+
+PCAL6408A_Type g_pcal6408aDev;
+PF09_Type g_pf09Dev;
+PF53_Type g_pf5301Dev;
+PF53_Type g_pf5302Dev;
+PCA2131_Type g_pca2131Dev;
+
+irq_prio_info_t g_brdIrqPrioInfo[BOARD_NUM_IRQ_PRIO_IDX] =
+{
+    [BOARD_IRQ_PRIO_IDX_GPIO1_0] =
+    {
+        .irqId = GPIO1_0_IRQn,
+        .irqCntr = 0U,
+        .basePrio = 0U,
+        .dynPrioEn = false
+    }
+};
+
+bool g_pca2131Used = false;
+
+uint32_t g_pmicFaultFlags = 0U;
+
+/* Local functions */
+
+static void BRD_SM_Pf09Handler(void);
+
+/*--------------------------------------------------------------------------*/
+/* Init serial devices                                                      */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_SerialDevicesInit(void)
+{
+    int32_t status = SM_ERR_SUCCESS;
+    LPI2C_Type *const s_i2cBases[] = LPI2C_BASE_PTRS;
+    pcal6408a_config_t pcal6408Config;
+
+    /* Fill in PCAL6408A dev */
+    g_pcal6408aDev.i2cBase = s_i2cBases[BOARD_I2C_INSTANCE];
+    g_pcal6408aDev.devAddr = BOARD_PCAL6408A_DEV_ADDR;
+
+    /* Init the bus expander */
+    PCAL6408A_GetDefaultConfig(&pcal6408Config);
+    pcal6408Config.inputLatch = 0xFFU;
+    if (!PCAL6408A_Init(&g_pcal6408aDev, &pcal6408Config))
+    {
+        status = SM_ERR_HARDWARE_ERROR;
+    }
+    else
+    {
+        if (!PCAL6408A_IntMaskSet(&g_pcal6408aDev, PCAL6408A_INITIAL_MASK))
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+
+    if (status == SM_ERR_SUCCESS)
+    {
+        /* Fill in PF09 PMIC handle */
+        g_pf09Dev.i2cBase = s_i2cBases[BOARD_I2C_INSTANCE];
+        g_pf09Dev.devAddr = BOARD_PF09_DEV_ADDR;
+        g_pf09Dev.crcEn = true;
+
+        /* Initialize PF09 PMIC */
+        if (!PF09_Init(&g_pf09Dev))
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+
+        /* Disable voltage monitor 1 */
+        if (status == SM_ERR_SUCCESS)
+        {
+            if (!PF09_MonitorEnable(&g_pf09Dev, PF09_VMON1, false))
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+        }
+
+        /* Disable voltage monitor 2 */
+        if (status == SM_ERR_SUCCESS)
+        {
+            if (!PF09_MonitorEnable(&g_pf09Dev, PF09_VMON2, false))
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+        }
+
+        /* Disable the PWRUP interrupt */
+        if (status == SM_ERR_SUCCESS)
+        {
+            const uint8_t mask[PF09_MASK_LEN] =
+            {
+                [PF09_MASK_IDX_STATUS1] = 0x08U
+            };
+
+            if (!PF09_IntEnable(&g_pf09Dev, mask, PF09_MASK_LEN, false))
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+        }
+
+        /* Change the LDO3 sequence */
+        if (status == SM_ERR_SUCCESS)
+        {
+            if (!PF09_PmicWrite(&g_pf09Dev, 0x4AU, 0x1EU, 0xFFU))
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+        }
+
+        /* Set the LDO3 OV bypass */
+        if (status == SM_ERR_SUCCESS)
+        {
+            if (!PF09_PmicWrite(&g_pf09Dev, 0x7FU, 0xFCU, 0xFFU))
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+        }
+
+        /* Enable the LDO3 in RUN mode */
+        if (status == SM_ERR_SUCCESS)
+        {
+            if (!PF09_PmicWrite(&g_pf09Dev, 0x7DU, 0x20U, 0xFFU))
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+        }
+
+        /* Set the OV debounce to 50us due to errata ER011/12 */
+        if (status == SM_ERR_SUCCESS)
+        {
+            if (!PF09_PmicWrite(&g_pf09Dev, 0x37U, 0x94U, 0xFFU))
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+        }
+
+        /* Save and clear any fault flags */
+        if (status == SM_ERR_SUCCESS)
+        {
+            if (!PF09_FaultFlags(&g_pf09Dev, &g_pmicFaultFlags, true))
+            {
+                status = SM_ERR_HARDWARE_ERROR;
+            }
+        }
+
+        /* Handle any already pending PF09 interrupts */
+        if (status == SM_ERR_SUCCESS)
+        {
+            BRD_SM_Pf09Handler();
+        }
+    }
+
+    if (status == SM_ERR_SUCCESS)
+    {
+        /* Fill in PF5301 PMIC handle */
+        g_pf5301Dev.i2cBase = s_i2cBases[BOARD_I2C_INSTANCE];
+        g_pf5301Dev.devAddr = BOARD_PF5301_DEV_ADDR;
+
+        /* Initialize PF5301 PMIC */
+        if (!PF53_Init(&g_pf5301Dev))
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+
+    }
+
+    if (status == SM_ERR_SUCCESS)
+    {
+        /* Fill in PF5302 PMIC handle */
+        g_pf5302Dev.i2cBase = s_i2cBases[BOARD_I2C_INSTANCE];
+        g_pf5302Dev.devAddr = BOARD_PF5302_DEV_ADDR;
+
+        /* Initialize PF5302 PMIC */
+        if (!PF53_Init(&g_pf5302Dev))
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+
+    if (status == SM_ERR_SUCCESS)
+    {
+        /* Fill in PCA2131 RTC handle */
+        g_pca2131Dev.i2cBase = s_i2cBases[BOARD_I2C_INSTANCE];
+        g_pca2131Dev.devAddr = BOARD_PCA2131_DEV_ADDR;
+
+        /* Initialize PCA2131 RTC */
+        if (!PCA2131_Init(&g_pca2131Dev))
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+
+    if (status == SM_ERR_SUCCESS)
+    {
+        rgpio_pin_config_t gpioConfig =
+        {
+            kRGPIO_DigitalInput,
+            0U
+        };
+
+        /* Init GPIO1-10 */
+        RGPIO_PinInit(GPIO1, 10U, &gpioConfig);
+        RGPIO_SetPinInterruptConfig(GPIO1, 10U, kRGPIO_InterruptOutput0,
+            kRGPIO_InterruptLogicZero);
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Set bus expander interrupt mask                                          */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_BusExpMaskSet(uint8_t val, uint8_t mask)
+{
+    int32_t status = SM_ERR_SUCCESS;
+    static uint8_t cachedMask = PCAL6408A_INITIAL_MASK;
+    uint8_t newMask = (cachedMask & ~mask);
+
+    newMask |= val;
+
+    /* Mask changed? */
+    if (cachedMask != newMask)
+    {
+        if (PCAL6408A_IntMaskSet(&g_pcal6408aDev, newMask))
+        {
+            cachedMask = newMask;
+        }
+        else
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* GPIO1 handler                                                            */
+/*--------------------------------------------------------------------------*/
+void GPIO1_0_IRQHandler(void)
+{
+    uint32_t flags;
+    uint8_t status, val;
+
+    /* Get GPIO status */
+    flags = RGPIO_GetPinsInterruptFlags(GPIO1, kRGPIO_InterruptOutput0);
+
+    /* Get PCAL6408A status */
+    (void) PCAL6408A_IntStatusGet(&g_pcal6408aDev, &status);
+
+    /* Get value and Clear PCAL6408A interrupts */
+    (void) PCAL6408A_InputGet(&g_pcal6408aDev, &val);
+
+    /* Clear GPIO interrupts */
+    RGPIO_ClearPinsInterruptFlags(GPIO1, kRGPIO_InterruptOutput0, flags);
+
+    /* Handle PF09 interrupt */
+    if ((status & BIT8(PCAL6408A_INPUT_PF09_INT)) != 0U)
+    {
+        /* Asserts low */
+        if ((val & BIT8(PCAL6408A_INPUT_PF09_INT)) == 0U)
+        {
+            BRD_SM_Pf09Handler();
+        }
+    }
+
+    /* Handle PCA2131 interrupt */
+    if (g_pca2131Used && ((status & BIT8(PCAL6408A_INPUT_PCA2131_INT))
+        != 0U))
+    {
+        /* Asserts low */
+        if ((val & BIT8(PCAL6408A_INPUT_PCA2131_INT)) == 0U)
+        {
+            BRD_SM_BbmHandler();
+        }
+    }
+
+    /* Handle controls interrupts */
+    BRD_SM_ControlHandler(status, val);
+
+    /* Adjust dynamic IRQ priority */
+    (void) DEV_SM_IrqPrioUpdate();
+}
+
+/*==========================================================================*/
+
+/*--------------------------------------------------------------------------*/
+/* PF09 handler                                                             */
+/*--------------------------------------------------------------------------*/
+static void BRD_SM_Pf09Handler(void)
+{
+    uint8_t stat[PF09_MASK_LEN] = { 0 };
+
+    /* Read status of interrupts */
+    (void) PF09_IntStatus(&g_pf09Dev, stat, PF09_MASK_LEN);
+
+    /* Clear pending */
+    (void) PF09_IntClear(&g_pf09Dev, stat, PF09_MASK_LEN);
+
+    /* Handle pending temp interrupts */
+    if ((stat[PF09_MASK_IDX_STATUS2] & 0x0FU) != 0U)
+    {
+        BRD_SM_SensorHandler();
+    }
+}
+
diff --git a/boards/ccimx95dvk/sm/brd_sm_handlers.h b/boards/ccimx95dvk/sm/brd_sm_handlers.h
new file mode 100755
index 000000000000..e34d52b50f7a
--- /dev/null
+++ b/boards/ccimx95dvk/sm/brd_sm_handlers.h
@@ -0,0 +1,129 @@
+/*
+** ###################################################################
+**
+** Copyright 2023-2024 NXP
+**
+** Redistribution and use in source and binary forms, with or without modification,
+** are permitted provided that the following conditions are met:
+**
+** o Redistributions of source code must retain the above copyright notice, this list
+**   of conditions and the following disclaimer.
+**
+** o Redistributions in binary form must reproduce the above copyright notice, this
+**   list of conditions and the following disclaimer in the documentation and/or
+**   other materials provided with the distribution.
+**
+** o Neither the name of the copyright holder nor the names of its
+**   contributors may be used to endorse or promote products derived from this
+**   software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+** LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+** ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**
+** ###################################################################
+*/
+
+#ifndef BRD_SM_HANDLERS_H
+#define BRD_SM_HANDLERS_H
+
+/*==========================================================================*/
+/*!
+ * @addtogroup BRD_SM_MX95EVK
+ * @{
+ *
+ * @file
+ * @brief
+ *
+ * Header file containing the implementation of interrupt handlers for the
+ * board.
+ */
+/*==========================================================================*/
+
+/* Includes */
+
+#include "sm.h"
+#include "dev_sm.h"
+#include "fsl_pcal6408a.h"
+#include "fsl_pf09.h"
+#include "fsl_pf53.h"
+#include "fsl_pca2131.h"
+
+/* Defines */
+
+/*! Initial PCAL6408A interrupt mask */
+#define PCAL6408A_INITIAL_MASK  0xF7U
+
+/*! Number of board IRQs participating dynamic prioritization */
+#define BOARD_NUM_IRQ_PRIO_IDX                 1U
+
+/*! Dynamic IRQ priority table index for GPIO1 */
+#define BOARD_IRQ_PRIO_IDX_GPIO1_0             0U
+
+/* Types */
+
+/* External variables */
+
+/*! Handle to access PCAL6408A */
+extern PCAL6408A_Type g_pcal6408aDev;
+
+/*! Handle to access PF09 */
+extern PF09_Type g_pf09Dev;
+
+/*! Handle to access PF5301 */
+extern PF53_Type g_pf5301Dev;
+
+/*! Handle to access PF5302 */
+extern PF53_Type g_pf5302Dev;
+
+/*! Handle to access PCA2131 */
+extern PCA2131_Type g_pca2131Dev;
+
+/*! Array of dynamic priority info for board IRQs */
+extern irq_prio_info_t g_brdIrqPrioInfo[BOARD_NUM_IRQ_PRIO_IDX];
+
+/*! Indicator if bus expander bit[6] is used for the PF2131 RTC */
+extern bool g_pca2131Used;
+
+/*! Fault flags from the PMICs */
+extern uint32_t g_pmicFaultFlags;
+
+/* Functions */
+
+/*!
+ * Init serial devices.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ */
+int32_t BRD_SM_SerialDevicesInit(void);
+
+/*!
+ * Enable/disable bus expander interrupts.
+ *
+ * @param[in]     val      Value to write
+ * @param[in]     mask     Mask of bits to modify
+ *
+ * This function allows a caller to configure the bus expander.
+ * interrupts.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ */
+int32_t BRD_SM_BusExpMaskSet(uint8_t val, uint8_t mask);
+
+/*!
+ * GPIO 1 interrupt 0 handler.
+ */
+void GPIO1_0_IRQHandler(void);
+
+/** @} */
+
+#endif /* BRD_SM_HANDLERS_H */
+
diff --git a/boards/ccimx95dvk/sm/brd_sm_sensor.c b/boards/ccimx95dvk/sm/brd_sm_sensor.c
new file mode 100755
index 000000000000..92e415459477
--- /dev/null
+++ b/boards/ccimx95dvk/sm/brd_sm_sensor.c
@@ -0,0 +1,375 @@
+/*
+** ###################################################################
+**
+** Copyright 2023-2025 NXP
+**
+** Redistribution and use in source and binary forms, with or without modification,
+** are permitted provided that the following conditions are met:
+**
+** o Redistributions of source code must retain the above copyright notice, this list
+**   of conditions and the following disclaimer.
+**
+** o Redistributions in binary form must reproduce the above copyright notice, this
+**   list of conditions and the following disclaimer in the documentation and/or
+**   other materials provided with the distribution.
+**
+** o Neither the name of the copyright holder nor the names of its
+**   contributors may be used to endorse or promote products derived from this
+**   software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+** LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+** ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**
+** ###################################################################
+*/
+
+/*==========================================================================*/
+/* File containing the implementation of the board sensors.                 */
+/*==========================================================================*/
+
+/* Includes */
+
+#include "sm.h"
+#include "brd_sm.h"
+#include "lmm.h"
+
+/* Local defines */
+
+/* Local types */
+
+/* Local variables */
+
+static bool sensorEnb[BRD_SM_NUM_SENSOR];
+
+/*--------------------------------------------------------------------------*/
+/* Return sensor name                                                       */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_SensorNameGet(uint32_t sensorId, string *sensorNameAddr,
+    int32_t *len)
+{
+    int32_t status = SM_ERR_SUCCESS;
+    static int32_t s_maxLen = 0;
+
+    static string const s_name[BRD_SM_NUM_SENSOR] =
+    {
+        "temp_pf09",
+        "temp_pf53_soc",
+        "temp_pf53_arm"
+    };
+
+    /* Get max string width */
+    DEV_SM_MaxStringGet(len, &s_maxLen, s_name, BRD_SM_NUM_SENSOR);
+
+    /* Check to see if sensorId is within bounds */
+    if (sensorId < SM_NUM_SENSOR)
+    {
+        /* Check if device or board */
+        if (sensorId < DEV_SM_NUM_SENSOR)
+        {
+            status = DEV_SM_SensorNameGet(sensorId, sensorNameAddr, len);
+        }
+        else
+        {
+            uint32_t brdSensorId = sensorId - DEV_SM_NUM_SENSOR;
+
+            /* Return pointer to name */
+            *sensorNameAddr = s_name[brdSensorId];
+        }
+    }
+    else
+    {
+        status = SM_ERR_NOT_FOUND;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Return sensor description                                                */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_SensorDescribe(uint32_t sensorId,
+    dev_sm_sensor_desc_t *desc)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Check to see if sensorId is within bounds */
+    if (sensorId < SM_NUM_SENSOR)
+    {
+        /* Check if device or board */
+        if (sensorId < DEV_SM_NUM_SENSOR)
+        {
+            status = DEV_SM_SensorDescribe(sensorId, desc);
+        }
+        else
+        {
+            desc->sensorType = 2U;
+            desc->sensorExponent = 0;
+            desc->numTripPoints = 0U;
+            desc->timestampSupport = false;
+            desc->timestampExponent = 0;
+
+            /* PF09? */
+            if (sensorId == BRD_SM_SENSOR_TEMP_PF09)
+            {
+                desc->numTripPoints = 1U;
+            }
+        }
+    }
+    else
+    {
+        status = SM_ERR_NOT_FOUND;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Get sensor reading                                                       */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_SensorReadingGet(uint32_t sensorId, int64_t *sensorValue,
+    uint64_t *sensorTimestamp)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Check to see if sensorId is within bounds */
+    if (sensorId < SM_NUM_SENSOR)
+    {
+        /* Check if device or board */
+        if (sensorId < DEV_SM_NUM_SENSOR)
+        {
+            status = DEV_SM_SensorReadingGet(sensorId, sensorValue,
+                sensorTimestamp);
+        }
+        else
+        {
+            uint32_t brdSensorId = sensorId - DEV_SM_NUM_SENSOR;
+
+            /* Check if enabled */
+            if (sensorEnb[brdSensorId])
+            {
+                int32_t temp;
+                bool rc = false;
+
+                /* Read sensor */
+                switch (sensorId)
+                {
+                    case BRD_SM_SENSOR_TEMP_PF09:
+                        rc = PF09_TempGet(&g_pf09Dev, &temp);
+                        break;
+                    case BRD_SM_SENSOR_TEMP_PF5301:
+                        rc = PF53_TempGet(&g_pf5301Dev, &temp);
+                        break;
+                    default:
+                        rc = PF53_TempGet(&g_pf5302Dev, &temp);
+                        break;
+                }
+
+                if (rc)
+                {
+                    *sensorValue = (int64_t) temp;
+                    *sensorTimestamp = 0ULL;
+                }
+                else
+                {
+                    status = SM_ERR_HARDWARE_ERROR;
+                }
+            }
+            else
+            {
+                status = SM_ERR_NOT_SUPPORTED;
+            }
+        }
+    }
+    else
+    {
+        status = SM_ERR_NOT_FOUND;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Set sensor trippoint                                                     */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_SensorTripPointSet(uint32_t sensorId, uint8_t tripPoint,
+    int64_t value, uint8_t eventControl)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Check to see if sensorId is within bounds */
+    if (sensorId < SM_NUM_SENSOR)
+    {
+        /* Check if device or board */
+        if (sensorId < DEV_SM_NUM_SENSOR)
+        {
+            status = DEV_SM_SensorTripPointSet(sensorId, tripPoint,
+                value, eventControl);
+        }
+        else
+        {
+            uint32_t brdSensorId = sensorId - DEV_SM_NUM_SENSOR;
+
+            /* Check if enabled */
+            if ((sensorId == BRD_SM_SENSOR_TEMP_PF09)
+                && sensorEnb[brdSensorId])
+            {
+                /* Check trip point */
+                if (tripPoint == 0U)
+                {
+                    if (eventControl == DEV_SM_SENSOR_TP_NONE)
+                    {
+                        if (!PF09_TempAlarmSet(&g_pf09Dev, 500))
+                        {
+                            status = SM_ERR_HARDWARE_ERROR;
+                        }
+                    }
+                    else if (eventControl == DEV_SM_SENSOR_TP_RISING)
+                    {
+                        /* Check value is within int32_t range */
+                        if (CHECK_I64_FIT_I32(value))
+                        {
+                            int32_t temp = (int32_t) value;
+
+                            if (!PF09_TempAlarmSet(&g_pf09Dev, temp))
+                            {
+                                status = SM_ERR_HARDWARE_ERROR;
+                            }
+                        }
+                        else
+                        {
+                            status = SM_ERR_INVALID_PARAMETERS;
+                        }
+                    }
+                    else
+                    {
+                        status = SM_ERR_INVALID_PARAMETERS;
+                    }
+                }
+                else
+                {
+                    status = SM_ERR_INVALID_PARAMETERS;
+                }
+            }
+            else
+            {
+                status = SM_ERR_NOT_SUPPORTED;
+            }
+        }
+    }
+    else
+    {
+        status = SM_ERR_NOT_FOUND;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Enable/disable sensor                                                    */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_SensorEnable(uint32_t sensorId, bool enable,
+    bool timestampReporting)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Check to see if sensorId is within bounds */
+    if (sensorId < SM_NUM_SENSOR)
+    {
+        /* Check if device or board */
+        if (sensorId < DEV_SM_NUM_SENSOR)
+        {
+            status = DEV_SM_SensorEnable(sensorId, enable,
+                timestampReporting);
+        }
+        else
+        {
+            uint32_t brdSensorId = sensorId - DEV_SM_NUM_SENSOR;
+
+            /* Timestamp not supported */
+            if (timestampReporting)
+            {
+                status = SM_ERR_NOT_SUPPORTED;
+            }
+            else
+            {
+                /* Record sensor enable */
+                sensorEnb[brdSensorId] = enable;
+
+                /* Disable alarm */
+                if ((sensorId == BRD_SM_SENSOR_TEMP_PF09)
+                    && !sensorEnb[brdSensorId])
+                {
+                    if (!PF09_TempAlarmSet(&g_pf09Dev, 500))
+                    {
+                        status = SM_ERR_HARDWARE_ERROR;
+                    }
+                }
+            }
+        }
+    }
+    else
+    {
+        status = SM_ERR_NOT_FOUND;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Return sensor enable status                                              */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_SensorIsEnabled(uint32_t sensorId, bool *enabled,
+    bool *timestampReporting)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Check to see if sensorId is within bounds */
+    if (sensorId < SM_NUM_SENSOR)
+    {
+        uint32_t brdSensorId = sensorId - DEV_SM_NUM_SENSOR;
+
+        /* Check if device or board */
+        if (sensorId < DEV_SM_NUM_SENSOR)
+        {
+            status = DEV_SM_SensorIsEnabled(sensorId, enabled,
+                timestampReporting);
+        }
+        else
+        {
+            /* Return sensor enable */
+            *enabled = sensorEnb[brdSensorId];
+            *timestampReporting = false;
+        }
+    }
+    else
+    {
+        status = SM_ERR_NOT_FOUND;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* PMIC sensor handler                                                      */
+/*--------------------------------------------------------------------------*/
+void BRD_SM_SensorHandler(void)
+{
+    /* Send sensor event */
+    LMM_SensorEvent(BRD_SM_SENSOR_TEMP_PF09, 0U, 1U);
+}
+
diff --git a/boards/ccimx95dvk/sm/brd_sm_sensor.h b/boards/ccimx95dvk/sm/brd_sm_sensor.h
new file mode 100755
index 000000000000..98b68ae9d53a
--- /dev/null
+++ b/boards/ccimx95dvk/sm/brd_sm_sensor.h
@@ -0,0 +1,210 @@
+/*
+** ###################################################################
+**
+** Copyright 2023 NXP
+**
+** Redistribution and use in source and binary forms, with or without modification,
+** are permitted provided that the following conditions are met:
+**
+** o Redistributions of source code must retain the above copyright notice, this list
+**   of conditions and the following disclaimer.
+**
+** o Redistributions in binary form must reproduce the above copyright notice, this
+**   list of conditions and the following disclaimer in the documentation and/or
+**   other materials provided with the distribution.
+**
+** o Neither the name of the copyright holder nor the names of its
+**   contributors may be used to endorse or promote products derived from this
+**   software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+** LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+** ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**
+** ###################################################################
+*/
+
+/*==========================================================================*/
+/*!
+ * @addtogroup BRD_SM_MX95EVK
+ * @{
+ *
+ * @file
+ * @brief
+ *
+ * Header file containing the SM API for the board sensors.
+ */
+/*==========================================================================*/
+
+#ifndef BRD_SM_SENSOR_H
+#define BRD_SM_SENSOR_H
+
+/* Includes */
+
+#include "sm.h"
+#include "dev_sm.h"
+
+/* Defines */
+
+/*!
+ * @name Board redirection defines
+ * @{
+ */
+#define SM_SENSORNAMEGET       BRD_SM_SensorNameGet       /*!< Sensor name */
+#define SM_SENSORDESCRIBE      BRD_SM_SensorDescribe      /*!< Sensor describe */
+#define SM_SENSORREADINGGET    BRD_SM_SensorReadingGet    /*!< Sensor read */
+#define SM_SENSORTRIPPOINTSET  BRD_SM_SensorTripPointSet  /*!< Sensor trip point */
+#define SM_SENSORENABLE        BRD_SM_SensorEnable        /*!< Sensor enable */
+#define SM_SENSORISENABLED     BRD_SM_SensorIsEnabled     /*!< Sensor status */
+/** @} */
+
+/*! Number of board sensors */
+#define BRD_SM_NUM_SENSOR  3UL
+
+/*! Total number of sensors */
+#define SM_NUM_SENSOR  (DEV_SM_NUM_SENSOR + BRD_SM_NUM_SENSOR)
+
+/*!
+ * @name BRD_SM sensor domain indexes
+ */
+/** @{ */
+#define BRD_SM_SENSOR_TEMP_PF09    (DEV_SM_NUM_SENSOR + 0U)  /*!< PF09 temp sensor */
+#define BRD_SM_SENSOR_TEMP_PF5302  (DEV_SM_NUM_SENSOR + 1U)  /*!< PF5302 temp sensor */
+#define BRD_SM_SENSOR_TEMP_PF5301  (DEV_SM_NUM_SENSOR + 2U)  /*!< PF5301 temp sensor */
+/** @} */
+
+/* Types */
+
+/* Functions */
+
+/*!
+ * @name Board sensor functions
+ * @{
+ */
+
+/*!
+ * Get a board sensor name.
+ *
+ * @param[in]     sensorId        Sensor name to get
+ * @param[out]    sensorNameAddr  Return pointer to name
+ * @param[out]    len             Return max length of all sensor names
+ *
+ * This function allows the caller to get the name of a sensor.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a sensorId is invalid.
+ */
+int32_t BRD_SM_SensorNameGet(uint32_t sensorId, string *sensorNameAddr,
+    int32_t *len);
+
+/*!
+ * Get a board sensor description.
+ *
+ * @param[in]     sensorId   Sensor description to get
+ * @param[out]    desc       Return pointer to the description
+ *
+ * This function allows the caller to get the description of a sensor.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a sensorId is invalid.
+ */
+int32_t BRD_SM_SensorDescribe(uint32_t sensorId,
+    dev_sm_sensor_desc_t *desc);
+
+/*!
+ * Read a board sensor.
+ *
+ * @param[in]     sensorId         Sensor to read
+ * @param[out]    sensorValue      Return pointer to sensor value
+ * @param[out]    sensorTimestamp  Return pointer to timestamp
+ *
+ * This function allows the caller to read the value of a sensor.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a sensorId is invalid.
+ */
+int32_t BRD_SM_SensorReadingGet(uint32_t sensorId, int64_t *sensorValue,
+    uint64_t *sensorTimestamp);
+
+/*!
+ * Configure a trip point for a board sensor.
+ *
+ * @param[in]     sensorId      Sensor to configure TP
+ * @param[in]     tripPoint     Trip point ID
+ * @param[in]     value         Value to trip at
+ * @param[in]     eventControl  Event control (notifications)
+ *
+ * This function allows the caller to configure one of the trip
+ * points for a sensor. The caller can also configure which crossing
+ * direction will generate a notification.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a sensorId is invalid.
+ */
+int32_t BRD_SM_SensorTripPointSet(uint32_t sensorId, uint8_t tripPoint,
+    int64_t value, uint8_t eventControl);
+
+/*!
+ * Enable/disable a board sensor.
+ *
+ * @param[in]     sensorId            Sensor to enable/disable
+ * @param[in]     enable              True to enable
+ * @param[in]     timestampReporting  True to enable timestamp reporting
+ *
+ * This function allows the caller to enable/disable a sensor.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a sensorId is invalid.
+ */
+int32_t BRD_SM_SensorEnable(uint32_t sensorId, bool enable,
+    bool timestampReporting);
+
+/*!
+ * Get enable/disable state of a board sensor.
+ *
+ * @param[in]     sensorId            Sensor to get state
+ * @param[out]    enabled             Return pointer to enable
+ * @param[out]    timestampReporting  Return pointer to reporting
+ *
+ * This function allows the caller to get the enable/disable
+ * state of a sensor.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a sensorId is invalid.
+ */
+int32_t BRD_SM_SensorIsEnabled(uint32_t sensorId, bool *enabled,
+    bool *timestampReporting);
+
+/*!
+ * Sensor interrupt handler.
+ *
+ * Called by PF09 interrupt handler.
+ */
+void BRD_SM_SensorHandler(void);
+
+/** @} */
+
+#endif /* BRD_SM_SENSOR_H */
+
+/** @} */
+
diff --git a/boards/ccimx95dvk/sm/brd_sm_voltage.c b/boards/ccimx95dvk/sm/brd_sm_voltage.c
new file mode 100755
index 000000000000..b81ffd970294
--- /dev/null
+++ b/boards/ccimx95dvk/sm/brd_sm_voltage.c
@@ -0,0 +1,565 @@
+/*
+** ###################################################################
+**
+**     Copyright 2023-2025 NXP
+**
+**     Redistribution and use in source and binary forms, with or without modification,
+**     are permitted provided that the following conditions are met:
+**
+**     o Redistributions of source code must retain the above copyright notice, this list
+**       of conditions and the following disclaimer.
+**
+**     o Redistributions in binary form must reproduce the above copyright notice, this
+**       list of conditions and the following disclaimer in the documentation and/or
+**       other materials provided with the distribution.
+**
+**     o Neither the name of the copyright holder nor the names of its
+**       contributors may be used to endorse or promote products derived from this
+**       software without specific prior written permission.
+**
+**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**
+** ###################################################################
+*/
+
+/*==========================================================================*/
+/* File containing the implementation of the board voltages.                */
+/*==========================================================================*/
+
+/* Includes */
+
+#include "sm.h"
+#include "brd_sm.h"
+
+/* Local defines */
+
+/* Local types */
+
+/* Local variables */
+
+static int32_t s_levelSoc = BOARD_VOLT_SOC;
+static int32_t s_levelArm = BOARD_VOLT_ARM;
+static uint32_t s_modeArm = DEV_SM_VOLT_MODE_ON;
+static uint32_t s_modeArmSave = DEV_SM_VOLT_MODE_ON;
+
+/*--------------------------------------------------------------------------*/
+/* Return voltage name                                                      */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_VoltageNameGet(uint32_t domainId, string *voltNameAddr,
+    int32_t *len)
+{
+    int32_t status = SM_ERR_SUCCESS;
+    static int32_t s_maxLen = 0;
+
+    static string const s_name[BRD_SM_NUM_VOLT] =
+    {
+        "vdd_gpio_3p3",
+        "vdd_ana_0p8",
+        "vdd_gpio_1p8",
+        "vddq_ddr",
+        "vdd2_ddr",
+        "sd_card",
+        "nvcc_sd2"
+    };
+
+    /* Get max string width */
+    DEV_SM_MaxStringGet(len, &s_maxLen, s_name, BRD_SM_NUM_VOLT);
+
+    /* Check to see if domain is within bounds*/
+    if (domainId < SM_NUM_VOLT)
+    {
+        /* Check if device or board */
+        if (domainId < DEV_SM_NUM_VOLT)
+        {
+            status = DEV_SM_VoltageNameGet(domainId, voltNameAddr, len);
+        }
+        else
+        {
+            /* Return pointer to name */
+            *voltNameAddr = s_name[domainId - DEV_SM_NUM_VOLT];
+        }
+    }
+    else
+    {
+        status = SM_ERR_NOT_FOUND;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Return supported voltage range                                           */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_VoltageDescribe(uint32_t domainId,
+    dev_sm_voltage_range_t *range)
+{
+    int32_t status = SM_ERR_HARDWARE_ERROR;
+    bool rc = false;
+    PF09_RegInfo info;
+
+    /* Get voltage range/info */
+    switch (domainId)
+    {
+        case DEV_SM_VOLT_SOC:
+            status = DEV_SM_VoltageDescribe(domainId, range);
+            break;
+        case DEV_SM_VOLT_ARM:
+            status = DEV_SM_VoltageDescribe(domainId, range);
+            break;
+        case BRD_SM_VOLT_VDD_GPIO_3P3:
+            rc = PF09_RegulatorInfoGet(PF09_REG_SW1, &info);
+            break;
+        case BRD_SM_VOLT_VDD_ANA_0P8:
+            rc = PF09_RegulatorInfoGet(PF09_REG_SW2, &info);
+            break;
+        case BRD_SM_VOLT_VDD_GPIO_1P8:
+            rc = PF09_RegulatorInfoGet(PF09_REG_SW3, &info);
+            break;
+        case BRD_SM_VOLT_VDDQ_DDR:
+            rc = PF09_RegulatorInfoGet(PF09_REG_SW4, &info);
+            break;
+        case BRD_SM_VOLT_VDD2_DDR:
+            rc = PF09_RegulatorInfoGet(PF09_REG_SW5, &info);
+            break;
+        case BRD_SM_VOLT_SD_CARD:
+            rc = PF09_RegulatorInfoGet(PF09_REG_LDO1, &info);
+            break;
+        case BRD_SM_VOLT_NVCC_SD2:
+            rc = PF09_RegulatorInfoGet(PF09_REG_LDO2, &info);
+            break;
+        default:
+            status = SM_ERR_NOT_FOUND;
+            break;
+    }
+
+    /* Return results */
+    if ((status != SM_ERR_SUCCESS) && rc)
+    {
+        /* Validate the parameters values are with in int32 range */
+        if (CHECK_U32_FIT_I32(info.maxV) &&
+            CHECK_U32_FIT_I32(info.minV) &&
+            CHECK_U32_FIT_I32(info.stepV))
+        {
+            range->highestVolt = (int32_t) info.maxV;
+            range->lowestVolt = (int32_t) info.minV;
+            range->stepSize = (int32_t) info.stepV;
+            status = SM_ERR_SUCCESS;
+        }
+        else
+        {
+            /* Set the status if parameters are out of range */
+            status = SM_ERR_INVALID_PARAMETERS;
+        }
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Set voltage mode                                                         */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_VoltageModeSet(uint32_t domainId, uint8_t voltMode)
+{
+    int32_t status = SM_ERR_SUCCESS;
+    bool enable = (voltMode == DEV_SM_VOLT_MODE_ON);
+    uint8_t mode = ((voltMode == DEV_SM_VOLT_MODE_OFF)
+        ? PF09_SW_MODE_OFF : PF09_SW_MODE_PWM);
+    bool rc;
+
+    /* Set mode */
+    switch (domainId)
+    {
+        case DEV_SM_VOLT_SOC:
+            mode = ((voltMode == DEV_SM_VOLT_MODE_OFF)
+                ? PF53_SW_MODE_OFF : PF53_SW_MODE_PWM);
+            rc = PF53_SwModeSet(&g_pf5302Dev, PF53_REG_SW1, PF53_STATE_VRUN,
+                mode);
+            break;
+        case DEV_SM_VOLT_ARM:
+            rc = PF09_GpioCtrlSet(&g_pf09Dev, PF09_GPIO4, PF53_STATE_VRUN,
+                enable);
+            if (enable && rc)
+            {
+                /* Wait for PF53 power up and ramp */
+                SystemTimeDelay(1000U);
+
+                if (s_levelArm != BOARD_VOLT_ARM)
+                {
+                    /* Restore voltage as enable resets the PF53 */
+                    status = BRD_SM_VoltageLevelSet(domainId, s_levelArm);
+                }
+            }
+            if (rc)
+            {
+                s_modeArm = voltMode;
+            }
+            break;
+        case BRD_SM_VOLT_VDD_GPIO_3P3:
+            rc = PF09_SwModeSet(&g_pf09Dev, PF09_REG_SW1, PF09_STATE_VRUN,
+                mode);
+            break;
+        case BRD_SM_VOLT_VDD_ANA_0P8:
+            rc = PF09_SwModeSet(&g_pf09Dev, PF09_REG_SW2, PF09_STATE_VRUN,
+                mode);
+            break;
+        case BRD_SM_VOLT_VDD_GPIO_1P8:
+            rc = PF09_SwModeSet(&g_pf09Dev, PF09_REG_SW3, PF09_STATE_VRUN,
+                mode);
+            break;
+        case BRD_SM_VOLT_VDDQ_DDR:
+            rc = PF09_SwModeSet(&g_pf09Dev, PF09_REG_SW4, PF09_STATE_VRUN,
+                mode);
+            break;
+        case BRD_SM_VOLT_VDD2_DDR:
+            rc = PF09_SwModeSet(&g_pf09Dev, PF09_REG_SW5, PF09_STATE_VRUN,
+                mode);
+            break;
+        case BRD_SM_VOLT_SD_CARD:
+            rc = PF09_LdoEnable(&g_pf09Dev, PF09_REG_LDO1, PF09_STATE_VRUN,
+                enable);
+            break;
+        case BRD_SM_VOLT_NVCC_SD2:
+            rc = PF09_LdoEnable(&g_pf09Dev, PF09_REG_LDO2, PF09_STATE_VRUN,
+                enable);
+            break;
+        default:
+            status = SM_ERR_NOT_FOUND;
+            break;
+    }
+
+    /* Translate error */
+    if ((status == SM_ERR_SUCCESS) && !rc)
+    {
+        status = SM_ERR_HARDWARE_ERROR;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Get voltage mode                                                         */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_VoltageModeGet(uint32_t domainId, uint8_t *voltMode)
+{
+    int32_t status = SM_ERR_SUCCESS;
+    bool enable;
+    uint8_t mode;
+    bool rc;
+
+    /* Get mode */
+    switch (domainId)
+    {
+        case DEV_SM_VOLT_SOC:
+            rc = PF53_SwModeGet(&g_pf5302Dev, PF53_REG_SW1, PF53_STATE_VRUN,
+                &mode);
+            enable = (mode != PF53_SW_MODE_OFF);
+            break;
+        case DEV_SM_VOLT_ARM:
+            rc = PF09_GpioCtrlGet(&g_pf09Dev, PF09_GPIO4, PF53_STATE_VRUN,
+                &enable);
+            break;
+        case BRD_SM_VOLT_VDD_GPIO_3P3:
+            rc = PF09_SwModeGet(&g_pf09Dev, PF09_REG_SW1, PF09_STATE_VRUN,
+                &mode);
+            enable = (mode != PF09_SW_MODE_OFF);
+            break;
+        case BRD_SM_VOLT_VDD_ANA_0P8:
+            rc = PF09_SwModeGet(&g_pf09Dev, PF09_REG_SW2, PF09_STATE_VRUN,
+                &mode);
+            enable = (mode != PF09_SW_MODE_OFF);
+            break;
+        case BRD_SM_VOLT_VDD_GPIO_1P8:
+            rc = PF09_SwModeGet(&g_pf09Dev, PF09_REG_SW3, PF09_STATE_VRUN,
+                &mode);
+            enable = (mode != PF09_SW_MODE_OFF);
+            break;
+        case BRD_SM_VOLT_VDDQ_DDR:
+            rc = PF09_SwModeGet(&g_pf09Dev, PF09_REG_SW4, PF09_STATE_VRUN,
+                &mode);
+            enable = (mode != PF09_SW_MODE_OFF);
+            break;
+        case BRD_SM_VOLT_VDD2_DDR:
+            rc = PF09_SwModeGet(&g_pf09Dev, PF09_REG_SW5, PF09_STATE_VRUN,
+                &mode);
+            enable = (mode != PF09_SW_MODE_OFF);
+            break;
+        case BRD_SM_VOLT_SD_CARD:
+            rc = PF09_LdoIsEnabled(&g_pf09Dev, PF09_REG_LDO1, PF09_STATE_VRUN,
+                &enable);
+            break;
+        case BRD_SM_VOLT_NVCC_SD2:
+            rc = PF09_LdoIsEnabled(&g_pf09Dev, PF09_REG_LDO2, PF09_STATE_VRUN,
+                &enable);
+            break;
+        default:
+            status = SM_ERR_NOT_FOUND;
+            break;
+    }
+
+    /* Return result */
+    if ((status == SM_ERR_SUCCESS) && rc)
+    {
+        *voltMode = enable ? DEV_SM_VOLT_MODE_ON : DEV_SM_VOLT_MODE_OFF;
+    }
+
+    /* Translate error */
+    if ((status == SM_ERR_SUCCESS) && !rc)
+    {
+        status = SM_ERR_HARDWARE_ERROR;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Set voltage level                                                        */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_VoltageLevelSet(uint32_t domainId, int32_t voltageLevel)
+{
+    int32_t status = SM_ERR_SUCCESS;
+
+    /* Check voltageLevel is positive */
+    if (CHECK_I32_POSITIVE(voltageLevel))
+    {
+        bool rc;
+        uint32_t level = (uint32_t) voltageLevel;
+
+        /* Set level */
+        switch (domainId)
+        {
+            case DEV_SM_VOLT_SOC:
+                rc = PF53_VoltageSet(&g_pf5302Dev, PF53_REG_SW1, PF53_STATE_VRUN,
+                    level);
+
+                if (rc)
+                {
+                    /* Save level to restore */
+                    s_levelSoc = (int32_t) level;
+                }
+                break;
+            case DEV_SM_VOLT_ARM:
+                (void) PF53_VoltageSet(&g_pf5301Dev, PF53_REG_SW1, PF53_STATE_VRUN,
+                    level);
+
+                /* Save level to restore */
+                s_levelArm = (int32_t) level;
+                rc = true;
+                break;
+            case BRD_SM_VOLT_VDD_GPIO_3P3:
+                rc = PF09_VoltageSet(&g_pf09Dev, PF09_REG_SW1, PF09_STATE_VRUN,
+                    level);
+                break;
+            case BRD_SM_VOLT_VDD_ANA_0P8:
+                rc = PF09_VoltageSet(&g_pf09Dev, PF09_REG_SW2, PF09_STATE_VRUN,
+                    level);
+                break;
+            case BRD_SM_VOLT_VDD_GPIO_1P8:
+                rc = PF09_VoltageSet(&g_pf09Dev, PF09_REG_SW3, PF09_STATE_VRUN,
+                    level);
+                break;
+            case BRD_SM_VOLT_VDDQ_DDR:
+                rc = PF09_VoltageSet(&g_pf09Dev, PF09_REG_SW4, PF09_STATE_VRUN,
+                    level);
+                break;
+            case BRD_SM_VOLT_VDD2_DDR:
+                rc = PF09_VoltageSet(&g_pf09Dev, PF09_REG_SW5, PF09_STATE_VRUN,
+                    level);
+                break;
+            case BRD_SM_VOLT_SD_CARD:
+                rc = PF09_VoltageSet(&g_pf09Dev, PF09_REG_LDO1, PF09_STATE_VRUN,
+                    level);
+                break;
+            case BRD_SM_VOLT_NVCC_SD2:
+                rc = PF09_VoltageSet(&g_pf09Dev, PF09_REG_LDO2, PF09_STATE_VRUN,
+                    level);
+                break;
+            default:
+                status = SM_ERR_NOT_FOUND;
+                break;
+        }
+
+        /* Translate error */
+        if ((status == SM_ERR_SUCCESS) && !rc)
+        {
+            status = SM_ERR_HARDWARE_ERROR;
+        }
+    }
+    else
+    {
+        /* Set the status if voltageLevel is negative */
+        status = SM_ERR_INVALID_PARAMETERS;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Get voltage level                                                        */
+/*--------------------------------------------------------------------------*/
+int32_t BRD_SM_VoltageLevelGet(uint32_t domainId, int32_t *voltageLevel)
+{
+    int32_t status = SM_ERR_SUCCESS;
+    bool rc;
+    uint32_t level = 0U;
+
+    /* Get level */
+    switch (domainId)
+    {
+        case DEV_SM_VOLT_SOC:
+            rc = PF53_VoltageGet(&g_pf5302Dev, PF53_REG_SW1, PF53_STATE_VRUN,
+                &level);
+            break;
+        case DEV_SM_VOLT_ARM:
+            rc = PF53_VoltageGet(&g_pf5301Dev, PF53_REG_SW1, PF53_STATE_VRUN,
+                &level);
+            if (rc)
+            {
+                /* Check level is within int32_t range */
+                if (CHECK_U32_FIT_I32(level))
+                {
+                    /* Save level to restore */
+                    s_levelArm = (int32_t) level;
+                }
+                else
+                {
+                    /* Set status if level is not within int32_t range */
+                    status = SM_ERR_INVALID_PARAMETERS;
+                }
+            }
+            else
+            {
+                /* Check s_levelArm has positive value */
+                if (CHECK_I32_POSITIVE(s_levelArm))
+                {
+                    /* Return saved level */
+                    level = (uint32_t) s_levelArm;
+                    rc = true;
+                }
+                else
+                {
+                    /* Set the status if s_levelArm is negative */
+                    status = SM_ERR_INVALID_PARAMETERS;
+                    rc = false;
+                }
+            }
+            break;
+        case BRD_SM_VOLT_VDD_GPIO_3P3:
+            rc = PF09_VoltageGet(&g_pf09Dev, PF09_REG_SW1, PF09_STATE_VRUN,
+                &level);
+            break;
+        case BRD_SM_VOLT_VDD_ANA_0P8:
+            rc = PF09_VoltageGet(&g_pf09Dev, PF09_REG_SW2, PF09_STATE_VRUN,
+                &level);
+            break;
+        case BRD_SM_VOLT_VDD_GPIO_1P8:
+            rc = PF09_VoltageGet(&g_pf09Dev, PF09_REG_SW3, PF09_STATE_VRUN,
+                &level);
+            break;
+        case BRD_SM_VOLT_VDDQ_DDR:
+            rc = PF09_VoltageGet(&g_pf09Dev, PF09_REG_SW4, PF09_STATE_VRUN,
+                &level);
+            break;
+        case BRD_SM_VOLT_VDD2_DDR:
+            rc = PF09_VoltageGet(&g_pf09Dev, PF09_REG_SW5, PF09_STATE_VRUN,
+                &level);
+            break;
+        case BRD_SM_VOLT_SD_CARD:
+            rc = PF09_VoltageGet(&g_pf09Dev, PF09_REG_LDO1, PF09_STATE_VRUN,
+                &level);
+            break;
+        case BRD_SM_VOLT_NVCC_SD2:
+            rc = PF09_VoltageGet(&g_pf09Dev, PF09_REG_LDO2, PF09_STATE_VRUN,
+                &level);
+            break;
+        default:
+            status = SM_ERR_NOT_FOUND;
+            break;
+    }
+
+    /* Return result */
+    if ((status == SM_ERR_SUCCESS) && rc)
+    {
+        /* Check level value within int32_t range */
+        if (CHECK_U32_FIT_I32(level))
+        {
+            *voltageLevel = (int32_t) level;
+        }
+        else
+        {
+            status = SM_ERR_INVALID_PARAMETERS;
+        }
+    }
+
+    /* Translate error */
+    if ((status == SM_ERR_SUCCESS) && !rc)
+    {
+        status = SM_ERR_HARDWARE_ERROR;
+    }
+
+    /* Return status */
+    return status;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Suspend SoC voltages                                                     */
+/*--------------------------------------------------------------------------*/
+void BRD_SM_VoltageSuspend(bool offArm)
+{
+    /* Turn off VDD_ARM */
+    if (offArm && (s_modeArm != DEV_SM_VOLT_MODE_OFF))
+    {
+        /* Save VDD_ARM mode */
+        s_modeArmSave = s_modeArm;
+
+        (void) BRD_SM_VoltageModeSet(DEV_SM_VOLT_ARM, DEV_SM_VOLT_MODE_OFF);
+    }
+}
+
+/*--------------------------------------------------------------------------*/
+/* Restore SoC voltages                                                     */
+/*--------------------------------------------------------------------------*/
+void BRD_SM_VoltageRestore(void)
+{
+    /* Restore VDD_SOC level */
+    if (s_levelSoc != BOARD_VOLT_SOC)
+    {
+        /* Restore voltage as enable resets the PF53 */
+        (void) BRD_SM_VoltageLevelSet(DEV_SM_VOLT_SOC, s_levelSoc);
+    }
+
+    /* Restore VDD_ARM mode */
+    if (s_modeArm != s_modeArmSave)
+    {
+        if (PF09_GpioCtrlSet(&g_pf09Dev, PF09_GPIO4, PF53_STATE_VRUN,
+            true))
+        {
+            /* Wait for PF53 power up and ramp */
+            SystemTimeDelay(1000U);
+
+            s_modeArm = DEV_SM_VOLT_MODE_ON;
+        }
+    }
+
+    /* Restore VDD_ARM level */
+    if (s_levelArm != BOARD_VOLT_ARM)
+    {
+        /* Restore voltage as enable resets the PF53 */
+        (void) BRD_SM_VoltageLevelSet(DEV_SM_VOLT_ARM, s_levelArm);
+    }
+}
+
diff --git a/boards/ccimx95dvk/sm/brd_sm_voltage.h b/boards/ccimx95dvk/sm/brd_sm_voltage.h
new file mode 100755
index 000000000000..6c9e01286e7e
--- /dev/null
+++ b/boards/ccimx95dvk/sm/brd_sm_voltage.h
@@ -0,0 +1,213 @@
+/*
+** ###################################################################
+**
+**     Copyright 2023-2024 NXP
+**
+**     Redistribution and use in source and binary forms, with or without modification,
+**     are permitted provided that the following conditions are met:
+**
+**     o Redistributions of source code must retain the above copyright notice, this list
+**       of conditions and the following disclaimer.
+**
+**     o Redistributions in binary form must reproduce the above copyright notice, this
+**       list of conditions and the following disclaimer in the documentation and/or
+**       other materials provided with the distribution.
+**
+**     o Neither the name of the copyright holder nor the names of its
+**       contributors may be used to endorse or promote products derived from this
+**       software without specific prior written permission.
+**
+**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+**
+** ###################################################################
+*/
+
+/*==========================================================================*/
+/*!
+ * @addtogroup BRD_SM_MX95EVK
+ * @{
+ *
+ * @file
+ * @brief
+ *
+ * Header file containing the SM API for the board voltages.
+ */
+/*==========================================================================*/
+
+#ifndef BRD_SM_VOLTAGE_H
+#define BRD_SM_VOLTAGE_H
+
+/* Includes */
+
+#include "sm.h"
+#include "dev_sm.h"
+
+/* Defines */
+
+/*!
+ * @name Board redirection defines
+ * @{
+ */
+#define SM_VOLTAGENAMEGET       BRD_SM_VoltageNameGet   /*!< Voltage name */
+#define SM_VOLTAGEDESCRIBE      BRD_SM_VoltageDescribe  /*!< Voltage describe */
+#define SM_VOLTAGEMODESET       BRD_SM_VoltageModeSet   /*!< Set voltage mode */
+#define SM_VOLTAGEMODEGET       BRD_SM_VoltageModeGet   /*!< Get coltage mode */
+#define SM_VOLTAGELEVELSET      BRD_SM_VoltageLevelSet  /*!< Set voltage level */
+#define SM_VOLTAGELEVELGET      BRD_SM_VoltageLevelGet  /*!< Get voltage level */
+/** @} */
+
+/*! Number of board voltages */
+#define BRD_SM_NUM_VOLT  7UL
+
+/*! Total number of sensors */
+#define SM_NUM_VOLT  (DEV_SM_NUM_VOLT + BRD_SM_NUM_VOLT)
+
+/*!
+ * @name BRD_SM voltage domains
+ */
+/** @{ */
+#define BRD_SM_VOLT_VDD_GPIO_3P3  (DEV_SM_NUM_VOLT + 0U)  /*!< VDD GPIO 3.3v */
+#define BRD_SM_VOLT_VDD_ANA_0P8   (DEV_SM_NUM_VOLT + 1U)  /*!< VDD ANA 0.8v */
+#define BRD_SM_VOLT_VDD_GPIO_1P8  (DEV_SM_NUM_VOLT + 2U)  /*!< VDD GPIO 1.8v */
+#define BRD_SM_VOLT_VDDQ_DDR      (DEV_SM_NUM_VOLT + 3U)  /*!< DDR VDDQ */
+#define BRD_SM_VOLT_VDD2_DDR      (DEV_SM_NUM_VOLT + 4U)  /*!< DDR VDD2 */
+#define BRD_SM_VOLT_SD_CARD       (DEV_SM_NUM_VOLT + 5U)  /*!< SD1 */
+#define BRD_SM_VOLT_NVCC_SD2      (DEV_SM_NUM_VOLT + 6U)  /*!< SD2 */
+/** @} */
+
+/* Types */
+
+/* Functions */
+
+/*!
+ * Get a board voltage domain name.
+ *
+ * @param[in]     domainId        Domain name to get
+ * @param[out]    voltNameAddr    Return pointer to name
+ * @param[out]    len             Return max length of all domain names
+ *
+ * This function allows the caller to get the name of a voltage domain.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a domainId is invalid.
+ */
+int32_t BRD_SM_VoltageNameGet(uint32_t domainId, string *voltNameAddr,
+    int32_t *len);
+
+/*!
+ * Get a board voltage domain description.
+ *
+ * @param[in]     domainId  Voltage description to get
+ * @param[out]    range     Pointer to return range
+ *
+ * This function allows the caller to get the voltage range for
+ * a voltage. The range contains the high, low, and step voltage
+ * in microvolts (uV).
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a domainId is invalid.
+ */
+int32_t BRD_SM_VoltageDescribe(uint32_t domainId,
+    dev_sm_voltage_range_t *range);
+
+/*!
+ * Set a board voltage mode.
+ *
+ * @param[in]     domainId      Identifier for the voltage domain
+ * @param[in]     voltMode      Voltage mode to set
+ *
+ * This function allows the caller to set the current mode of
+ * a voltage domain.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a domainId is invalid.
+ */
+int32_t BRD_SM_VoltageModeSet(uint32_t domainId, uint8_t voltMode);
+
+/*!
+ * Get a board voltage mode.
+ *
+ * @param[in]     domainId      Identifier for the voltage domain
+ * @param[out]    voltMode      Pointer to return the voltage mode
+ *
+ * This function allows the caller to request the current mode of
+ * a voltage domain.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a domainId is invalid.
+ */
+int32_t BRD_SM_VoltageModeGet(uint32_t domainId, uint8_t *voltMode);
+
+/*!
+ * Set a board voltage level.
+ *
+ * @param[in]     domainId      Identifier for the voltage domain
+ * @param[in]     voltageLevel  Voltage level to set
+ *
+ * This function allows the caller to set the current level of
+ * a voltage domain.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a domainId is invalid.
+ * - ::SM_ERR_INVALID_PARAMETERS: if \a voltageLevel is negative.
+ * - other from BRD_SM_SupplyLevelSet()
+ */
+int32_t BRD_SM_VoltageLevelSet(uint32_t domainId, int32_t voltageLevel);
+
+/*!
+ * Get a board voltage level.
+ *
+ * @param[in]     domainId      Identifier for the voltage domain
+ * @param[out]    voltageLevel  Pointer to return the voltage level
+ *
+ * This function allows the caller to request the current level of
+ * a voltage domain.
+ *
+ * @return Returns the status (::SM_ERR_SUCCESS = success).
+ *
+ * Return errors (see @ref STATUS "SM error codes"):
+ * - ::SM_ERR_NOT_FOUND: if \a domainId is invalid.
+ * - other from BRD_SM_SupplyLevelGet()
+ */
+int32_t BRD_SM_VoltageLevelGet(uint32_t domainId, int32_t *voltageLevel);
+
+/*!
+ * Suspend voltage modes/levels.
+ *
+ * @param[in]     offArm        Turn off VDD_ARM if on
+ *
+ * This function saves and disabled the ARM voltage.
+ */
+void BRD_SM_VoltageSuspend(bool offArm);
+
+/*!
+ * Restore voltage modes/levels.
+ *
+ * This function writes the last set voltage levels back to the PMICs.
+ */
+void BRD_SM_VoltageRestore(void);
+
+#endif /* BRD_SM_VOLTAGE_H */
+
+/** @} */
+
diff --git a/configs/ccimx95dvk.cfg b/configs/ccimx95dvk.cfg
new file mode 100755
index 000000000000..d05e1214df8a
--- /dev/null
+++ b/configs/ccimx95dvk.cfg
@@ -0,0 +1,997 @@
+## ###################################################################
+##
+## Copyright 2023-2025 NXP
+##
+## Redistribution and use in source and binary forms, with or without modification,
+## are permitted provided that the following conditions are met:
+##
+## o Redistributions of source code must retain the above copyright notice, this list
+##   of conditions and the following disclaimer.
+##
+## o Redistributions in binary form must reproduce the above copyright notice, this
+##   list of conditions and the following disclaimer in the documentation and/or
+##   other materials provided with the distribution.
+##
+## o Neither the name of the copyright holder nor the names of its
+##   contributors may be used to endorse or promote products derived from this
+##   software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+## ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+## WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+## DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+## ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+## ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+## (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+## SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+##
+##
+## ###################################################################
+
+# SM configuration file for the MX95 EVK
+
+MAKE    soc=MIMX95, board=mcimx95evk, build=gcc_cross
+DOX     name=MX95EVK, desc="i.MX95 EVK Configuration Data"
+
+include ../devices/MIMX95/configtool/device.cfg
+
+#==========================================================================#
+# Board                                                                    #
+#==========================================================================#
+
+BOARD               DEBUG_UART_INSTANCE=2
+BOARD               DEBUG_UART_BAUDRATE=115200
+
+BOARD               I2C_INSTANCE=1
+BOARD               I2C_BAUDRATE=400000
+
+#==========================================================================#
+# Common Defines                                                           #
+#==========================================================================#
+
+NOTIFY:             api=notify
+GET:                api=get
+SET:                api=set
+PRIV:               api=priv
+ALL:                api=all
+READONLY:           perm=ro
+
+#==========================================================================#
+# ELE Domain                                                               #
+#==========================================================================#
+
+DOM0                did=0
+
+DATA:               perm=rw
+
+# Resources
+
+# Memory
+
+M33_TCM_SYS         DATA, begin=0x020200000, size=256K
+OCRAM               DATA, begin=0x020480000, size=352K
+DDR                 DATA, begin=0x080000000, end=0x87FFFFFFF, nodbg
+
+#==========================================================================#
+# ISP Domain                                                               #
+#==========================================================================#
+
+DOM10               did=10
+
+OWNER:              perm=rw
+
+#==========================================================================#
+# V2X Domain                                                               #
+#==========================================================================#
+
+DOM12               did=12
+
+DFMT1:              sa=bypass, pa=bypass
+OWNER:
+
+# Resources
+
+V2X_FH              OWNER
+
+# Memory
+
+DDR                 DATA, begin=0x08B000000, end=0x08BFFFFFF, nodbg
+
+#==========================================================================#
+# SM M33 EENV                                                              #
+#==========================================================================#
+
+LM0                 name="SM", rpc=none, boot=1, did=2, safe=feenv
+
+DFMT0:              sa=secure
+DFMT1:              sa=secure, pa=privileged
+OWNER:              perm=sec_rw, api=all
+ACCESS:             perm=sec_rw, api=all, mdid=none
+TEST_MU:            perm=sec_rw
+
+EXEC:               perm=sec_rwx
+DATA:               perm=sec_rw
+
+MODE                msel=1, boot=1
+MODE                msel=2, boot=1
+
+# API
+
+# Modified via PERF protocol
+CLK_A55MTRBUS            ALL
+CLK_ADC                  ALL
+CLK_BUSAON               ALL
+CLK_BUSM7                ALL
+CLK_BUSNETCMIX           ALL
+CLK_BUSWAKEUP            ALL
+CLK_CAMAPB               ALL
+CLK_CAMAXI               ALL
+CLK_CAMCM0               ALL
+CLK_CAMISI               ALL
+CLK_DISPAPB              ALL
+CLK_DISPAXI              ALL
+CLK_ELE                  ALL
+CLK_ENET                 ALL
+CLK_ENETPHYTEST200M      ALL
+CLK_ENETPHYTEST500M      ALL
+CLK_ENETPHYTEST667M      ALL
+CLK_FRO                  ALL
+CLK_GPU                  ALL
+CLK_GPUAPB               ALL
+CLK_HSIO                 ALL
+CLK_HSIOACSCAN480M       ALL
+CLK_HSIOACSCAN80M        ALL
+CLK_HSIOPCIETEST160M     ALL
+CLK_HSIOPCIETEST400M     ALL
+CLK_HSIOPCIETEST500M     ALL
+CLK_HSIOUSBTEST50M       ALL
+CLK_HSIOUSBTEST60M       ALL
+CLK_NOC                  ALL
+CLK_NOCAPB               ALL
+CLK_NPU                  ALL
+CLK_NPUAPB               ALL
+CLK_OSC24M               ALL
+CLK_OSC32K               ALL
+CLK_SYSPLL1_PFD0         ALL
+CLK_SYSPLL1_PFD0_DIV2    ALL
+CLK_SYSPLL1_PFD0_UNGATED ALL
+CLK_SYSPLL1_PFD1         ALL
+CLK_SYSPLL1_PFD1_DIV2    ALL
+CLK_SYSPLL1_PFD1_UNGATED ALL
+CLK_SYSPLL1_PFD2         ALL
+CLK_SYSPLL1_PFD2_DIV2    ALL
+CLK_SYSPLL1_PFD2_UNGATED ALL
+CLK_SYSPLL1_VCO          ALL
+CLK_TEMPSENSE_GPR_SEL    ALL
+CLK_TMU                  ALL
+CLK_V2XPK                ALL
+CLK_VPU                  ALL
+CLK_VPUAPB               ALL
+CLK_VPUJPEG              ALL
+CLK_WAKEUPAXI            ALL
+
+# Resources
+
+M33P                OWNER  # CPUs must be first
+ANATOP              OWNER
+ATU_A               OWNER
+ATU_M               OWNER
+AXBS_AON            OWNER
+BBNSM               OWNER
+BLK_CTRL_BBSMMIX    OWNER
+BLK_CTRL_DDRMIX     OWNER
+BLK_CTRL_GPUMIX     OWNER
+BLK_CTRL_NOCMIX     OWNER
+BLK_CTRL_NS_AONMIX  OWNER
+BLK_CTRL_S_AONMIX   OWNER
+BLK_CTRL_WAKEUPMIX  OWNER
+CCM                 OWNER
+DAP                 OWNER
+DDR_CTRL            OWNER
+DDR_PHY             OWNER
+DDR_PM              OWNER
+DRAM_PLL            OWNER
+ELE                 OWNER
+FSB                 READONLY
+GIC                 ACCESS
+GPC                 OWNER
+GPIO1               OWNER
+GPR0                OWNER
+GPR1                OWNER
+GPR2                OWNER
+GPR3                OWNER
+GPV_CAMERA          OWNER
+GPV_CENTRAL         OWNER
+GPV_DISPLAY         OWNER
+GPV_HSIO            OWNER
+GPV_MAIN            OWNER
+GPV_MEGA            OWNER
+GPV_VPU             OWNER
+IOMUXC              OWNER
+IOMUX_GPR           OWNER
+JTAG                OWNER
+LPI2C1              OWNER
+LPUART2             OWNER
+M33_CACHE_CTRL      OWNER
+M33_PCF             OWNER
+M33_PSF             OWNER
+M33_TCM_ECC         OWNER
+MU1_A               TEST_MU
+MU1_B               OWNER
+MU2_A               TEST_MU
+MU2_B               OWNER
+MU3_A               TEST_MU
+MU3_B               OWNER
+MU4_A               TEST_MU
+MU4_B               OWNER
+MU5_A               TEST_MU
+MU5_B               OWNER
+MU6_A               TEST_MU
+MU6_B               OWNER
+MU_ELE0             OWNER
+ROMCP_M33           OWNER
+SRAM_CTL_1          OWNER
+SRAM_CTL_N          OWNER
+SRC                 OWNER
+SYSCTR_CTL          OWNER
+SYSCTR_RD           OWNER
+TEMP_A55            OWNER
+TRDC_A              OWNER
+TRDC_C              OWNER
+TRDC_D              OWNER
+TRDC_E              OWNER
+TRDC_G              OWNER
+TRDC_H              OWNER
+TRDC_M              OWNER
+TRDC_N              OWNER
+TRDC_V              OWNER
+TRDC_W              OWNER
+TSTMR1              OWNER
+WDOG1               OWNER
+WDOG2               OWNER
+
+# SAF
+
+CMU_A1              OWNER
+CMU_A2              OWNER
+CMU_ANA             OWNER
+CMU_DDR1            OWNER
+CMU_DDR2            OWNER
+CMU_N1              OWNER
+CMU_N2              OWNER
+CMU_W1              OWNER
+CMU_W2              OWNER
+CRC_A               OWNER
+C_STCU              OWNER
+DMA_CRC             OWNER
+EIM_A               OWNER
+EIM_N               OWNER
+EIM_NPU             OWNER
+EIM_W               OWNER
+ERM_A               OWNER
+ERM_NPU             OWNER
+ERM_W               OWNER
+FCCU                OWNER
+FCCU_FHID           OWNER
+INTM                OWNER
+L_STCU_A            OWNER
+L_STCU_DDR          OWNER
+L_STCU_N            OWNER
+L_STCU_NPUMIX       OWNER
+
+# Pins
+
+PIN_FCCU_ERR0         OWNER
+PIN_I2C1_SCL          OWNER
+PIN_I2C1_SDA          OWNER
+PIN_PDM_BIT_STREAM1   OWNER
+PIN_UART2_RXD         OWNER
+PIN_UART2_TXD         OWNER
+PIN_WDOG_ANY          OWNER
+
+# Memory
+
+M33_ROM             EXEC, begin=0x000000000, end=0x00003FFFF
+M33_TCM_CODE        EXEC, begin=0x0201C0000, size=256K
+M33_TCM_SYS         EXEC, begin=0x020200000, size=256K
+M7MIX               DATA, begin=0x04A050000, end=0x04A0AFFFF
+
+# Faults
+
+FAULT_SW3           OWNER, reaction=grp_reset
+FAULT_SW4           OWNER, reaction=sys_reset
+
+#==========================================================================#
+# M7 EENV                                                                  #
+#==========================================================================#
+
+LM1                 name="M7", rpc=scmi, boot=2, skip=1, did=4, safe=seenv
+
+DFMT0:              sa=secure
+DFMT1:              sa=secure, pa=privileged
+OWNER:              perm=rw, api=all
+
+EXEC:               perm=full
+DATA:               perm=rw
+
+# Start/Stop (mSel=0)
+
+PD_M7               start=1, stop=2
+CPU_M7P             start=2, stop=1
+
+# Start/Stop (mSel=1)
+
+MODE                msel=1, boot=2
+
+PD_M7               msel=1, start=1, stop=2
+CPU_M7P             msel=1, start=2, stop=1
+
+# Start/Stop (mSel=2)
+
+PD_M7               msel=2, start=1, stop=2
+CPU_M7P             msel=2, start=2, stop=1
+
+# RPC Interface
+
+SCMI_AGENT0         name="M7"
+MAILBOX             type=mu, mu=9, test=8, priority=high
+CHANNEL             db=0, xport=smt, check=crc32, rpc=scmi, type=a2p, \
+                    test=default
+CHANNEL             db=1, xport=smt, check=crc32, rpc=scmi, \
+                    type=p2a_notify, notify=24
+CHANNEL             db=2, xport=smt, check=crc32, rpc=scmi, \
+                    type=p2a_priority
+
+# API
+
+BRD_SM_CTRL_BUTTON        NOTIFY
+BRD_SM_CTRL_PCA2131       ALL
+BRD_SM_CTRL_TEST          ALL
+BRD_SM_RTC_PCA2131        ALL
+BRD_SM_SENSOR_TEMP_PF09   SET
+BRD_SM_SENSOR_TEMP_PF5301 SET
+BRD_SM_SENSOR_TEMP_PF5302 SET
+BUTTON                    NOTIFY
+FUSA                      ALL
+LMM_2                     ALL
+RTC                       PRIV
+SENSOR_TEMP_ANA           ALL, test
+SYS                       ALL
+
+# Resources
+
+M7P                 OWNER  # CPUs must be first
+CAN_FD1             OWNER
+FSB                 READONLY
+IRQSTEER_M7         OWNER
+LPIT1               OWNER
+LPTMR1              OWNER
+LPTMR2              OWNER
+LPTPM1              OWNER
+LPUART3             OWNER, test
+MSGINTR1            OWNER
+MSGINTR2            OWNER
+MU5_A               OWNER
+MU7_B               OWNER
+MU8_B               OWNER
+MU_ELE5             OWNER
+PD_M7               test
+SYSCTR_RD           READONLY
+TSTMR2              OWNER
+V2X_SHE1            OWNER
+WDOG5               OWNER
+
+# Pins
+
+PIN_GPIO_IO14       OWNER
+PIN_GPIO_IO15       OWNER
+
+# Memory
+
+M7MIX               DATA, begin=0x020380000, end=0x02047FFFF
+M7MIX               DATA, begin=0x04A060000, end=0x04A09FFFF
+DDR                 EXEC, begin=0x080000000, end=0x089FFFFFF
+
+# Faults
+
+FAULT_M7_LOCKUP     OWNER, reaction=lm_reset
+FAULT_M7_RESET      OWNER, reaction=lm_reset
+FAULT_SW0           OWNER, reaction=fusa
+FAULT_SW1           OWNER, reaction=lm_reset
+FAULT_WDOG5         OWNER, reaction=lm_reset
+
+#==========================================================================#
+# A55 secure EENV                                                          #
+#==========================================================================#
+
+LM2                 name="AP", rpc=scmi, boot=3, skip=1, did=3, default
+
+DFMT0:              sa=bypass
+DFMT1:              sa=secure, pa=privileged
+OWNER:              perm=sec_rw, api=all
+
+EXEC:               perm=sec_rwx
+DATA:               perm=rw
+
+# Start/Stop (mSel=0)
+
+VOLT_ARM            start=1|1, stop=9
+PD_A55P             start=2, stop=8, test
+PD_A55C0            stop=7
+PD_A55C1            stop=6
+PD_A55C2            stop=5
+PD_A55C3            stop=4
+PD_A55C4            stop=3
+PD_A55C5            stop=2
+PERF_A55            start=3|3
+CPU_A55C0           start=4
+CPU_A55P            stop=1
+
+# Start/Stop (mSel=1)
+
+VOLT_ARM            msel=1, start=1|1, stop=9
+PD_A55P             msel=1, start=2, stop=8
+PD_A55C0            msel=1, stop=7
+PD_A55C1            msel=1, stop=6
+PD_A55C2            msel=1, stop=5
+PD_A55C3            msel=1, stop=4
+PD_A55C4            msel=1, stop=3
+PD_A55C5            msel=1, stop=2
+PERF_A55            msel=1, start=3|3
+CPU_A55C0           msel=1, start=4
+CPU_A55P            msel=1, stop=1
+
+# Start/Stop (mSel=2)
+
+VOLT_ARM            msel=2, start=1|1, stop=9
+PD_A55P             msel=2, start=2, stop=8
+PD_A55C0            msel=2, stop=7
+PD_A55C1            msel=2, stop=6
+PD_A55C2            msel=2, stop=5
+PD_A55C3            msel=2, stop=4
+PD_A55C4            msel=2, stop=3
+PD_A55C5            msel=2, stop=2
+PERF_A55            msel=2, start=3|3
+CPU_A55C0           msel=2, start=4
+CPU_A55P            msel=2, stop=1
+
+# RPC Interface
+
+SCMI_AGENT1         name="AP-S", secure
+MAILBOX             type=mu, mu=1, test=0
+CHANNEL             db=0, xport=smt, rpc=scmi, type=a2p
+CHANNEL             db=1, xport=smt, rpc=scmi, type=p2a_notify
+
+# API
+
+PERF_A55            ALL
+PERF_DRAM           ALL
+PERLPI_CAN2         ALL
+PERLPI_CAN3         ALL
+PERLPI_CAN4         ALL
+PERLPI_CAN5         ALL
+PERLPI_GPIO2        ALL
+PERLPI_GPIO3        ALL
+PERLPI_GPIO4        ALL
+PERLPI_GPIO5        ALL
+PERLPI_LPUART1      ALL
+PERLPI_LPUART4      ALL
+PERLPI_LPUART5      ALL
+PERLPI_LPUART6      ALL
+PERLPI_LPUART7      ALL
+PERLPI_LPUART8      ALL
+PERLPI_WDOG3        ALL
+PERLPI_WDOG4        ALL
+SYS                 ALL
+
+# Resources
+
+A55C0               OWNER  # CPUs must be first
+A55C1               OWNER  # CPUs must be first
+A55C2               OWNER  # CPUs must be first
+A55C3               OWNER  # CPUs must be first
+A55C4               OWNER  # CPUs must be first
+A55C5               OWNER  # CPUs must be first
+A55P                OWNER, sema=0x442313F8
+ARM_PLL             OWNER
+MU1_A               OWNER
+MU_ELE1             OWNER
+MU_ELE2             OWNER
+
+# Pins
+
+# Memory
+
+OCRAM               EXEC, begin=0x020480000, size=256K
+DDR                 EXEC, begin=0x08A000000, end=0x08DFFFFFF
+
+# Faults
+
+FAULT_SW2           OWNER, reaction=lm_reset
+FAULT_WDOG3         OWNER, reaction=lm_reset
+FAULT_WDOG4         OWNER, reaction=lm_reset
+
+#==========================================================================#
+# A55 non-secure EENV                                                      #
+#==========================================================================#
+
+DFMT0:              sa=nonsecure
+DFMT1:              sa=nonsecure, pa=privileged
+
+OWNER:              perm=rw, api=all
+ACCESS:             perm=rw, api=all, mdid=none
+
+EXEC:               perm=full
+DATA:               perm=rw
+
+# RPC Interface
+
+SCMI_AGENT2         name="AP-NS"
+MAILBOX             type=mu, mu=3, test=2
+CHANNEL             db=0, xport=smt, rpc=scmi, type=a2p
+CHANNEL             db=1, xport=smt, rpc=scmi, type=p2a_notify
+
+# API
+
+AUDIO_PLL1                ALL
+AUDIO_PLL2                ALL
+BRD_SM_CTRL_BT_WAKE       NOTIFY
+BRD_SM_CTRL_BUTTON        NOTIFY
+BRD_SM_CTRL_PCIE1_WAKE    NOTIFY
+BRD_SM_CTRL_PCIE2_WAKE    NOTIFY
+BRD_SM_CTRL_SD3_WAKE      NOTIFY
+BRD_SM_RTC_PCA2131        PRIV
+BRD_SM_SENSOR_TEMP_PF09   ALL
+BRD_SM_SENSOR_TEMP_PF5301 SET
+BRD_SM_SENSOR_TEMP_PF5302 SET
+BUTTON                    ALL, test
+CLOCK_DISP1PIX            ALL
+CLOCK_DISP2PIX            ALL
+CLOCK_DISP3PIX            ALL
+CLOCK_EXT                 ALL
+CLOCK_EXT1                ALL
+CLOCK_EXT2                ALL
+CLOCK_HSIOPCIEAUX         ALL
+CLOCK_OUT1                ALL
+CLOCK_OUT2                ALL
+CLOCK_OUT3                ALL
+CLOCK_OUT4                ALL
+CLOCK_USBPHYBURUNIN       ALL
+CLOCK_VPUDSP              ALL
+HSIO_PLL                  ALL
+LDB_PLL                   ALL
+LMM_1                     NOTIFY
+PERF_A55                  ALL
+PERF_DRAM                 ALL
+RTC                       ALL, test
+SENSOR_TEMP_A55           ALL
+SENSOR_TEMP_ANA           SET
+SYS                       NOTIFY
+
+# Resources
+
+ADC                 OWNER
+BLK_CTRL_CAMERAMIX  OWNER
+BLK_CTRL_DISPLAYMIX OWNER
+BLK_CTRL_HSIOMIX    OWNER
+BLK_CTRL_NETCMIX    OWNER
+BLK_CTRL_NPUMIX     OWNER
+BLK_CTRL_VPUMIX     OWNER
+CAMERA1             OWNER
+CAMERA2             OWNER
+CAMERA3             OWNER
+CAMERA4             OWNER
+CAMERA5             OWNER
+CAMERA6             OWNER
+CAMERA7             OWNER
+CAMERA8             OWNER
+CAN_FD2             OWNER
+CAN_FD3             OWNER
+CAN_FD4             OWNER
+CAN_FD5             OWNER
+DC                  OWNER, test
+DC0                 OWNER
+DC1                 OWNER
+DC_2DBLIT           OWNER
+DC_BLITINT          OWNER
+DC_CMDSEQ           OWNER
+DC_DISPENG          OWNER
+DC_DISPENG_INT      OWNER
+DC_FL0              OWNER
+DC_FL1              OWNER
+DC_INT_CTL          OWNER
+DC_PIXENGINE        OWNER
+DC_XPC              OWNER
+DC_YUV0             OWNER
+DC_YUV1             OWNER
+DC_YUV2             OWNER
+DC_YUV3             OWNER
+DDR_PM              ACCESS
+EDMA1_MP            OWNER
+EDMA1_CH0           OWNER
+EDMA1_CH1           OWNER
+EDMA1_CH2           OWNER
+EDMA1_CH3           OWNER
+EDMA1_CH4           OWNER
+EDMA1_CH5           OWNER
+EDMA1_CH6           OWNER
+EDMA1_CH7           OWNER
+EDMA1_CH8           OWNER
+EDMA1_CH9           OWNER
+EDMA1_CH10          OWNER
+EDMA1_CH11          OWNER
+EDMA1_CH12          OWNER
+EDMA1_CH13          OWNER
+EDMA1_CH14          OWNER
+EDMA1_CH15          OWNER
+EDMA1_CH16          OWNER
+EDMA1_CH17          OWNER
+EDMA1_CH18          OWNER
+EDMA1_CH19          OWNER
+EDMA1_CH20          OWNER
+EDMA1_CH21          OWNER
+EDMA1_CH22          OWNER
+EDMA1_CH23          OWNER
+EDMA1_CH24          OWNER
+EDMA1_CH25          OWNER
+EDMA1_CH26          OWNER
+EDMA1_CH27          OWNER
+EDMA1_CH28          OWNER
+EDMA1_CH29          OWNER
+EDMA1_CH30          OWNER
+EDMA1_CH31          OWNER
+EDMA2_MP            OWNER
+EDMA2_CH0_1         OWNER
+EDMA2_CH2_3         OWNER
+EDMA2_CH4_5         OWNER
+EDMA2_CH6_7         OWNER
+EDMA2_CH8_9         OWNER
+EDMA2_CH10_11       OWNER
+EDMA2_CH12_13       OWNER
+EDMA2_CH14_15       OWNER
+EDMA2_CH16_17       OWNER
+EDMA2_CH18_19       OWNER
+EDMA2_CH20_21       OWNER
+EDMA2_CH22_23       OWNER
+EDMA2_CH24_25       OWNER
+EDMA2_CH26_27       OWNER
+EDMA2_CH28_29       OWNER
+EDMA2_CH30_31       OWNER
+EDMA2_CH32_33       OWNER
+EDMA2_CH34_35       OWNER
+EDMA2_CH36_37       OWNER
+EDMA2_CH38_39       OWNER
+EDMA2_CH40_41       OWNER
+EDMA2_CH42_43       OWNER
+EDMA2_CH44_45       OWNER
+EDMA2_CH46_47       OWNER
+EDMA2_CH48_49       OWNER
+EDMA2_CH50_51       OWNER
+EDMA2_CH52_53       OWNER
+EDMA2_CH54_55       OWNER
+EDMA2_CH56_57       OWNER
+EDMA2_CH58_59       OWNER
+EDMA2_CH60_61_A     OWNER
+EDMA2_CH60_61_B     OWNER
+EDMA2_CH62_63_A     OWNER
+EDMA2_CH62_63_B     OWNER
+EDMA3_MP            OWNER
+EDMA3_CH0_1         OWNER
+EDMA3_CH2_3         OWNER
+EDMA3_CH4_5         OWNER
+EDMA3_CH6_7         OWNER
+EDMA3_CH8_9         OWNER
+EDMA3_CH10_11       OWNER
+EDMA3_CH12_13       OWNER
+EDMA3_CH14_15       OWNER
+EDMA3_CH16_17       OWNER
+EDMA3_CH18_19       OWNER
+EDMA3_CH20_21       OWNER
+EDMA3_CH22_23       OWNER
+EDMA3_CH24_25       OWNER
+EDMA3_CH26_27       OWNER
+EDMA3_CH28_29       OWNER
+EDMA3_CH30_31       OWNER
+EDMA3_CH32_33       OWNER
+EDMA3_CH34_35       OWNER
+EDMA3_CH36_37       OWNER
+EDMA3_CH38_39       OWNER
+EDMA3_CH40_41       OWNER
+EDMA3_CH42_43       OWNER
+EDMA3_CH44_45       OWNER
+EDMA3_CH46_47       OWNER
+EDMA3_CH48_49       OWNER
+EDMA3_CH50_51       OWNER
+EDMA3_CH52_53       OWNER
+EDMA3_CH54_55       OWNER
+EDMA3_CH56_57       OWNER
+EDMA3_CH58_59       OWNER
+EDMA3_CH60_61       OWNER
+EDMA3_CH62_63       OWNER
+FLEXIO1             OWNER
+FLEXIO2             OWNER
+FLEXSPI1            OWNER
+FSB                 READONLY
+GIC                 OWNER
+GPIO2               OWNER
+GPIO3               OWNER
+GPIO4               OWNER
+GPIO5               OWNER
+GPR4                OWNER, test
+GPR5                OWNER
+GPR6                OWNER
+GPR7                OWNER
+GPU_NPROT           OWNER
+GPU_PROT            OWNER, test
+I3C1                OWNER
+I3C2                OWNER
+ISI1                OWNER
+ISI2                OWNER
+ISI3                OWNER
+ISI4                OWNER
+ISI5                OWNER
+ISI6                OWNER
+ISI7                OWNER
+ISI8                OWNER
+ISP_CPU             OWNER
+ISP_MGR             OWNER, test
+JPEG_DEC            OWNER
+LPI2C2              OWNER
+LPI2C3              OWNER
+LPI2C4              OWNER
+LPI2C5              OWNER
+LPI2C6              OWNER
+LPI2C7              OWNER
+LPI2C8              OWNER
+LPIT2               OWNER
+LPSPI1              OWNER
+LPSPI2              OWNER
+LPSPI3              OWNER
+LPSPI4              OWNER
+LPSPI5              OWNER
+LPSPI6              OWNER
+LPSPI7              OWNER
+LPSPI8              OWNER
+LPTPM2              OWNER
+LPTPM3              OWNER
+LPTPM4              OWNER
+LPTPM5              OWNER
+LPTPM6              OWNER
+LPUART1             OWNER
+LPUART4             OWNER
+LPUART5             OWNER
+LPUART6             OWNER
+LPUART7             OWNER
+LPUART8             OWNER, test
+LVDS                OWNER
+MIPI_CSI0           OWNER
+MIPI_CSI1           OWNER
+MIPI_DSI            OWNER
+MIPI_PHY            OWNER
+MJPEG_DEC1          OWNER
+MJPEG_DEC2          OWNER
+MJPEG_DEC3          OWNER
+MJPEG_DEC4          OWNER
+MJPEG_ENC           OWNER
+MJPEG_ENC1          OWNER
+MJPEG_ENC2          OWNER
+MJPEG_ENC3          OWNER
+MJPEG_ENC4          OWNER
+MU2_A               OWNER
+MU3_A               OWNER
+MU4_A               OWNER
+MU6_A               OWNER
+MU7_A               OWNER
+MU8_A               OWNER
+MU_ELE3             OWNER
+MU_ELE4             OWNER
+NETC                OWNER, test
+NETC0               OWNER
+NETC1               OWNER
+NETC2               OWNER
+NETC_ECAM           OWNER
+NETC_EMDIO0         OWNER
+NETC_IERB           OWNER
+NETC_LDID1          OWNER, kpa=0, sid=0x20
+NETC_LDID2          OWNER, kpa=0, sid=0x21
+NETC_LDID3          OWNER, kpa=0, sid=0x22
+NETC_LDID4          OWNER, kpa=0, sid=0x23
+NETC_LDID5          OWNER, kpa=0, sid=0x24
+NETC_LDID6          OWNER, kpa=0, sid=0x25
+NETC_LDID7          OWNER, kpa=0, sid=0x26
+NETC_LDID8          OWNER, kpa=0, sid=0x27
+NETC_PRB            OWNER
+NETC_TIMER0         OWNER
+NETC_VSI0           OWNER
+NETC_VSI1           OWNER
+NETC_VSI2           OWNER
+NETC_VSI3           OWNER
+NETC_VSI4           OWNER
+NETC_VSI5           OWNER
+NPU                 OWNER, kpa=0, sid=0x0d, test
+PCI1_LUT0           OWNER, kpa=0, sid=0x10
+PCI1_LUT1           OWNER, kpa=0, sid=0x11
+PCI1_LUT2           OWNER, kpa=0, sid=0x12
+PCI1_LUT3           OWNER, kpa=0, sid=0x13
+PCI1_LUT4           OWNER, kpa=0, sid=0x14
+PCI1_LUT5           OWNER, kpa=0, sid=0x15
+PCI1_LUT6           OWNER, kpa=0, sid=0x16
+PCI1_LUT7           OWNER, kpa=0, sid=0x17
+PCI2_LUT0           OWNER, kpa=0, sid=0x18
+PCI2_LUT1           OWNER, kpa=0, sid=0x19
+PCI2_LUT2           OWNER, kpa=0, sid=0x1a
+PCI2_LUT3           OWNER, kpa=0, sid=0x1b
+PCI2_LUT4           OWNER, kpa=0, sid=0x1c
+PCI2_LUT5           OWNER, kpa=0, sid=0x1d
+PCI2_LUT6           OWNER, kpa=0, sid=0x1e
+PCI2_LUT7           OWNER, kpa=0, sid=0x1f
+PCIE1_OUT           OWNER
+PCIE1_ROOT          OWNER
+PCIE2_OUT           OWNER
+PCIE2_ROOT          OWNER
+PDM                 OWNER
+SAI1                OWNER, test
+SAI2                OWNER
+SAI3                OWNER
+SAI4                OWNER
+SAI5                OWNER
+SEMA41              OWNER
+SEMA42              OWNER
+SMMU                OWNER
+SPDIF1              OWNER
+SYSCTR_CMP          OWNER
+SYSCTR_RD_STOP      READONLY
+USB1                OWNER, kpa=0, sid=0xe, test
+USB2                OWNER, kpa=0, sid=0xf
+USDHC1              OWNER, kpa=0, sid=0x1
+USDHC2              OWNER, kpa=0, sid=0x2
+USDHC3              OWNER, kpa=0, sid=0x3
+V2X_APP0            OWNER
+V2X_DEBUG           OWNER
+V2X_HSM1            OWNER
+V2X_HSM2            OWNER
+V2X_SHE0            OWNER
+VIDEO_PLL1          OWNER
+VPU                 OWNER, test
+VPU1                OWNER
+VPU2                OWNER
+VPU3                OWNER
+VPU4                OWNER
+WDOG3               OWNER
+WDOG4               OWNER
+XSPI                OWNER
+
+# Pins
+
+PIN_CCM_CLKO1        OWNER
+PIN_CCM_CLKO2        OWNER
+PIN_CCM_CLKO3        OWNER
+PIN_CCM_CLKO4        OWNER
+PIN_DAP_TCLK_SWCLK   OWNER
+PIN_DAP_TDI          OWNER
+PIN_DAP_TDO_TRACESWO OWNER
+PIN_DAP_TMS_SWDIO    OWNER
+PIN_ENET1_MDC        OWNER
+PIN_ENET1_MDIO       OWNER
+PIN_ENET1_RD0        OWNER
+PIN_ENET1_RD1        OWNER
+PIN_ENET1_RD2        OWNER
+PIN_ENET1_RD3        OWNER
+PIN_ENET1_RX_CTL     OWNER
+PIN_ENET1_RXC        OWNER
+PIN_ENET1_TD0        OWNER
+PIN_ENET1_TD1        OWNER
+PIN_ENET1_TD2        OWNER
+PIN_ENET1_TD3        OWNER
+PIN_ENET1_TX_CTL     OWNER
+PIN_ENET1_TXC        OWNER
+PIN_ENET2_MDC        OWNER
+PIN_ENET2_MDIO       OWNER
+PIN_ENET2_RD0        OWNER
+PIN_ENET2_RD1        OWNER
+PIN_ENET2_RD2        OWNER
+PIN_ENET2_RD3        OWNER
+PIN_ENET2_RX_CTL     OWNER
+PIN_ENET2_RXC        OWNER
+PIN_ENET2_TD0        OWNER
+PIN_ENET2_TD1        OWNER
+PIN_ENET2_TD2        OWNER
+PIN_ENET2_TD3        OWNER
+PIN_ENET2_TX_CTL     OWNER
+PIN_ENET2_TXC        OWNER
+PIN_GPIO_IO00        OWNER
+PIN_GPIO_IO01        OWNER
+PIN_GPIO_IO02        OWNER
+PIN_GPIO_IO03        OWNER
+PIN_GPIO_IO04        OWNER
+PIN_GPIO_IO05        OWNER
+PIN_GPIO_IO06        OWNER
+PIN_GPIO_IO07        OWNER
+PIN_GPIO_IO08        OWNER
+PIN_GPIO_IO09        OWNER
+PIN_GPIO_IO10        OWNER
+PIN_GPIO_IO11        OWNER
+PIN_GPIO_IO12        OWNER
+PIN_GPIO_IO13        OWNER
+PIN_GPIO_IO16        OWNER
+PIN_GPIO_IO17        OWNER
+PIN_GPIO_IO18        OWNER
+PIN_GPIO_IO19        OWNER
+PIN_GPIO_IO20        OWNER
+PIN_GPIO_IO21        OWNER
+PIN_GPIO_IO22        OWNER
+PIN_GPIO_IO23        OWNER
+PIN_GPIO_IO24        OWNER
+PIN_GPIO_IO25        OWNER
+PIN_GPIO_IO26        OWNER
+PIN_GPIO_IO27        OWNER
+PIN_GPIO_IO28        OWNER
+PIN_GPIO_IO29        OWNER
+PIN_GPIO_IO30        OWNER
+PIN_GPIO_IO31        OWNER
+PIN_GPIO_IO32        OWNER
+PIN_GPIO_IO33        OWNER
+PIN_GPIO_IO34        OWNER
+PIN_GPIO_IO35        OWNER
+PIN_GPIO_IO36        OWNER
+PIN_GPIO_IO37        OWNER
+PIN_I2C2_SCL         OWNER
+PIN_I2C2_SDA         OWNER
+PIN_PDM_BIT_STREAM0  OWNER
+PIN_PDM_CLK          OWNER
+PIN_SAI1_RXD0        OWNER
+PIN_SAI1_TXC         OWNER
+PIN_SAI1_TXD0        OWNER
+PIN_SAI1_TXFS        OWNER
+PIN_SD1_CLK          OWNER
+PIN_SD1_CMD          OWNER
+PIN_SD1_DATA0        OWNER
+PIN_SD1_DATA1        OWNER
+PIN_SD1_DATA2        OWNER
+PIN_SD1_DATA3        OWNER
+PIN_SD1_DATA4        OWNER
+PIN_SD1_DATA5        OWNER
+PIN_SD1_DATA6        OWNER
+PIN_SD1_DATA7        OWNER
+PIN_SD1_STROBE       OWNER
+PIN_SD2_CD_B         OWNER
+PIN_SD2_CLK          OWNER
+PIN_SD2_CMD          OWNER
+PIN_SD2_DATA0        OWNER
+PIN_SD2_DATA1        OWNER
+PIN_SD2_DATA2        OWNER
+PIN_SD2_DATA3        OWNER
+PIN_SD2_RESET_B      OWNER
+PIN_SD2_VSELECT      OWNER
+PIN_SD3_CLK          OWNER
+PIN_SD3_CMD          OWNER
+PIN_SD3_DATA0        OWNER
+PIN_SD3_DATA1        OWNER
+PIN_SD3_DATA2        OWNER
+PIN_SD3_DATA3        OWNER
+PIN_UART1_RXD        OWNER, test
+PIN_UART1_TXD        OWNER
+PIN_XSPI1_DATA0      OWNER
+PIN_XSPI1_DATA1      OWNER
+PIN_XSPI1_DATA2      OWNER
+PIN_XSPI1_DATA3      OWNER
+PIN_XSPI1_DATA4      OWNER
+PIN_XSPI1_DATA5      OWNER
+PIN_XSPI1_DATA6      OWNER
+PIN_XSPI1_DATA7      OWNER
+PIN_XSPI1_DQS        OWNER
+PIN_XSPI1_SCLK       OWNER
+PIN_XSPI1_SS0_B      OWNER
+PIN_XSPI1_SS1_B      OWNER
+
+# Memory
+
+FLEXSPI1_MEM        EXEC, begin=0x000000000, end=0x0FFFFFFFF
+OCRAM_C             EXEC, begin=0x001000000, end=0x001017FFF
+OCRAM               EXEC, begin=0x0204C0000, size=96K
+GPU                 DATA, begin=0x04D900000, end=0x04DD7FFFF
+DDR                 EXEC, begin=0x088000000, end=0x089FFFFFF
+DDR                 EXEC, begin=0x08E000000, end=0x87FFFFFFF
+
